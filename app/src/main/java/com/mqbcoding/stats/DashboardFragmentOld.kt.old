package com.mqbcoding.stats

import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.ObjectAnimator
import android.app.Activity
import android.content.BroadcastReceiver
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.ServiceConnection
import android.content.SharedPreferences.OnSharedPreferenceChangeListener
import android.graphics.Color
import android.graphics.LightingColorFilter
import android.graphics.PorterDuff
import android.graphics.Typeface
import android.os.Bundle
import android.os.Handler
import android.os.IBinder
import android.preference.PreferenceManager
import android.text.format.DateFormat
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver.OnGlobalLayoutListener
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.TextView
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.content.ContextCompat
import androidx.localbroadcastmanager.content.LocalBroadcastManager
import com.github.anastr.speedviewlib.Gauge
import com.github.anastr.speedviewlib.RaySpeedometer
import com.github.anastr.speedviewlib.Speedometer
import com.github.anastr.speedviewlib.components.Indicators.ImageIndicator
import com.github.anastr.speedviewlib.components.Indicators.Indicator.Indicators
import com.github.martoreto.aauto.vex.CarStatsClient
import com.github.martoreto.aauto.vex.FieldSchema
import com.google.android.apps.auto.sdk.StatusBarController
import com.jjoe64.graphview.GraphView
import com.jjoe64.graphview.GridLabelRenderer
import com.jjoe64.graphview.series.DataPoint
import com.jjoe64.graphview.series.LineGraphSeries
import com.mqbcoding.stats.CarStatsService.CarStatsBinder
import com.mqbcoding.stats.GeocodeLocationService.IGeocodeResult
import com.mqbcoding.stats.GeocodeLocationService.LocalBinder
import org.prowl.torque.remote.ITorqueService
import java.math.BigInteger
import java.text.SimpleDateFormat
import java.util.Arrays
import java.util.Calendar
import java.util.Date
import java.util.GregorianCalendar
import java.util.Locale
import java.util.Random
import java.util.TimeZone
import java.util.Timer
import java.util.TimerTask

class DashboardFragmentOld : CarFragment() {
    private val TAG = "DashboardFragment"
    private var updateTimer: Timer? = null
    private var mStatsClient: CarStatsClient? = null
    private var mClockLeft: Speedometer? = null
    private var mClockCenter: Speedometer? = null
    private var mClockRight: Speedometer? = null
    private var mClockMaxLeft: Speedometer? = null
    private var mClockMaxCenter: Speedometer? = null
    private var mClockMaxRight: Speedometer? = null
    private var mRayLeft: RaySpeedometer? = null
    private var mRayCenter: RaySpeedometer? = null
    private var mRayRight: RaySpeedometer? = null
    private var mSteeringWheelAngle: ImageView? = null
    private var mElement1Query: String? = null
        set(v) {
            if (TorqueRefresher.isTorqueQuery(v)) {
                toqueRefresher.populateQuery(4, v)
            }
        }
    private var mElement2Query: String? = null
        set(v) {
            if (TorqueRefresher.isTorqueQuery(v)) {
                toqueRefresher.populateQuery(5, v)
            }
        }
    private var mElement3Query: String? = null
        set(v) {
            if (TorqueRefresher.isTorqueQuery(v)) {
                toqueRefresher.populateQuery(6, v)
            }
        }
    private var mElement4Query: String? = null
        set(v) {
            if (TorqueRefresher.isTorqueQuery(v)) {
                toqueRefresher.populateQuery(7, v)
            }
        }
    private var selectedTheme: String? = null
    private var selectedBackground: String? = null
    private var mClockLQuery: String? = null
        set(v) {
            if (TorqueRefresher.isTorqueQuery(v)) {
                toqueRefresher.populateQuery(1, v)
            }
        }
    private var mClockCQuery: String? = null
        set(v) {
            if (TorqueRefresher.isTorqueQuery(v)) {
                toqueRefresher.populateQuery(2, v)
            }
        }
    private var mClockRQuery: String? = null
        set(v) {
            if (TorqueRefresher.isTorqueQuery(v)) {
                toqueRefresher.populateQuery(3, v)
            }
        }
    private var pressureUnit: String? = null
        set(v) {
            toqueRefresher.populateQuery(4, v)
        }
    private var temperatureUnit: String? = null
    private var pressureFactor = 0f
    private val speedFactor = 0f
    private var powerFactor = 0f
    private var fueltanksize = 0f
    private var pressureMin = 0
    private var pressureMax = 0

    //icons/labels of the data elements. upper left, upper right, lower left, lower right.
    private var mIconElement1: TextView? = null
    private var mIconElement2: TextView? = null
    private var mIconElement3: TextView? = null
    private var mIconElement4: TextView? = null
    private var mValueElement1: TextView? = null
    private var mValueElement2: TextView? = null
    private var mValueElement3: TextView? = null
    private var mValueElement4: TextView? = null
    private var mTitleIcon1: TextView? = null
    private var mTitleIcon2: TextView? = null
    private var mTitleIcon3: TextView? = null
    private var mTitleIcon4: TextView? = null
    private var mConstraintClockLeft: ConstraintLayout? = null
    private var mConstraintClockRight: ConstraintLayout? = null
    private var mConstraintClockCenter: ConstraintLayout? = null
    private var mConstraintGraphLeft: ConstraintLayout? = null
    private var mConstraintGraphRight: ConstraintLayout? = null
    private var mConstraintGraphCenter: ConstraintLayout? = null
    private var mConstraintElementLeft: ConstraintLayout? = null
    private var mConstraintElementRight: ConstraintLayout? = null
    private var mConstraintElementCenter: ConstraintLayout? = null
    private var mValueLeftElement1: TextView? = null
    private var mValueLeftElement2: TextView? = null
    private var mValueLeftElement3: TextView? = null
    private var mValueLeftElement4: TextView? = null
    private var mValueLeftElement5: TextView? = null
    private var mValueLeftElement6: TextView? = null
    private var mValueCenterElement1: TextView? = null
    private var mValueCenterElement2: TextView? = null
    private var mValueCenterElement3: TextView? = null
    private var mValueCenterElement4: TextView? = null
    private var mValueCenterElement5: TextView? = null
    private var mValueCenterElement6: TextView? = null
    private var mValueRightElement1: TextView? = null
    private var mValueRightElement2: TextView? = null
    private var mValueRightElement3: TextView? = null
    private var mValueRightElement4: TextView? = null
    private var mValueRightElement5: TextView? = null
    private var mValueRightElement6: TextView? = null

    private var mtextTitleMain: TextView? = null

    //values of the data elements. upper left, upper right, lower left, lower right.
    private var mTitleElement: TextView? = null
    private var mTitleElementRight: TextView? = null
    private var mTitleElementLeft: TextView? = null
    private var mTitleElementNavDistance: TextView? = null
    private var mTitleElementNavTime: TextView? = null
    private var mTitleNAVDestinationAddress: TextView? = null
    private var mTitleClockLeft: TextView? = null
    private var mTitleClockCenter: TextView? = null
    private var mTitleClockRight: TextView? = null
    private var mTitleConsumptionLeft: TextView? = null
    private var mTitleConsumptionCenter: TextView? = null
    private var mTitleConsumptionRight: TextView? = null
    private var mTextMaxLeft: TextView? = null
    private var mTextMaxCenter: TextView? = null
    private var mTextMaxRight: TextView? = null

    //icons on the clocks
    private var mIconClockL: TextView? = null
    private var mIconClockC: TextView? = null
    private var mIconClockR: TextView? = null
    private val pressureUnits: Boolean? = null
    private val temperatureUnits: Boolean? = null
    private var stagingDone: Boolean? = null
    private var raysOn: Boolean? = null
    private var maxOn: Boolean? = null
    private var maxMarksOn: Boolean? = null
    private var ticksOn: Boolean? = null
    private var ambientOn: Boolean? = null
    private var accurateOn: Boolean? = null
    private var proximityOn: Boolean? = null
    private var Dashboard2_On: Boolean? = null
    private var Dashboard3_On: Boolean? = null
    private var Dashboard4_On: Boolean? = null
    private var Dashboard5_On: Boolean? = null
    private var mLastMeasurements: MutableMap<String, Any> = HashMap()
    private val mHandler: Handler = Handler()
    private var torqueService: ITorqueService? = null
    private val torqueBind = false
    private var mGraphLeft: GraphView? = null
    private var mGraphCenter: GraphView? = null
    private var mGraphRight: GraphView? = null
    private var mSpeedSeriesLeft: LineGraphSeries<DataPoint>? = null
    private var mSpeedSeriesCenter: LineGraphSeries<DataPoint>? = null
    private var mSpeedSeriesRight: LineGraphSeries<DataPoint>? = null
    private var graphLeftLastXValue = 5.0
    private var graphCenterLastXValue = 5.0
    private var graphRightLastXValue = 5.0

    //value displayed on graphlayout
    private var mGraphValueLeft: TextView? = null
    private var mGraphValueCenter: TextView? = null
    private var mGraphValueRight: TextView? = null
    private var rootView: View? = null
    private var mDashboard_gaudes: View? = null
    private var mDashboard_consumption: View? = null
    private var androidClockFormat = "hh:mm a"
    var dashboardNum = 1
    private var googleGeocodeLocationStr: String? = null
    private var googleMapsLocationStr: String? = null
    private var mGeocodingService: GeocodeLocationService? = null
    private var mBtnNext: ImageButton? = null
    private var mBtnPrev: ImageButton? = null
    private val mSchema: HashMap<String, FieldSchema>? = null
    private var statsBound = false
    private var celsiusTempUnit = false
    private var showStreetName = false
    private var useGoogleGeocoding = false
    private var forceGoogleGeocoding = false
    private var sourceLocation: String? = null
    private var selectedFont: String? = null
    private var selectedPressureUnits = false
    private var updateSpeed = 2000
    private var MaxspeedLeft: FloatArray? = null
    private var MaxspeedCenter: FloatArray? = null
    private var MaxspeedRight: FloatArray? = null
    private var toqueRefresher = TorqueRefresher()
    override fun setupStatusBar(sc: StatusBarController) {
        sc.hideTitle()
    }

    // todo: reset min/max when clock is touched
    private val resetMinMax = View.OnClickListener {
        MaxspeedLeft!![dashboardNum] = 0f
        MaxspeedCenter!![dashboardNum] = 0f
        MaxspeedRight!![dashboardNum] = 0f
        val speedLeft = MaxspeedLeft!![dashboardNum] // mClockLeft.getSpeed();
        val speedCenter = MaxspeedCenter!![dashboardNum] //;mClockCenter.getSpeed();
        val speedRight = MaxspeedRight!![dashboardNum] //mClockRight.getSpeed();
        mClockMaxLeft!!.speedTo(speedLeft)
        mClockMaxCenter!!.speedTo(speedCenter)
        mClockMaxRight!!.speedTo(speedRight)
        mTextMaxLeft!!.text = String.format(
            Locale.US,
            FORMAT_DECIMALS,
            speedLeft
        )
        mTextMaxCenter!!.text = String.format(
            Locale.US,
            FORMAT_DECIMALS,
            speedCenter
        )
        mTextMaxRight!!.text = String.format(
            Locale.US,
            FORMAT_DECIMALS,
            speedRight
        )
    }
    private val toggleView = View.OnClickListener { v ->
        if (v === mConstraintClockLeft) {
            fadeOutfadeIn(v, mConstraintGraphLeft)
            mTextMaxLeft!!.visibility = View.INVISIBLE
        } else if (v === mConstraintClockCenter) {
            fadeOutfadeIn(v, mConstraintGraphCenter)
            mTextMaxCenter!!.visibility = View.INVISIBLE
        } else if (v === mConstraintClockRight) {
            fadeOutfadeIn(v, mConstraintGraphRight)
            mTextMaxRight!!.visibility = View.INVISIBLE
        } else if (v === mGraphLeft) {
            fadeOutfadeIn(mConstraintGraphLeft, mConstraintClockLeft)
            if (maxOn!!) mTextMaxLeft!!.visibility = View.VISIBLE
        } else if (v === mGraphCenter) {
            fadeOutfadeIn(mConstraintGraphCenter, mConstraintClockCenter)
            if (maxOn!!) mTextMaxCenter!!.visibility = View.VISIBLE
        } else if (v === mGraphRight) {
            fadeOutfadeIn(mConstraintGraphRight, mConstraintClockRight)
            if (maxOn!!) mTextMaxRight!!.visibility = View.VISIBLE
        } else if (v === mBtnPrev) {
            dashboardNum++
            if (dashboardNum == 2 && !Dashboard2_On!!) dashboardNum++
            if (dashboardNum == 3 && !Dashboard3_On!!) dashboardNum++
            if (dashboardNum == 4 && !Dashboard4_On!!) dashboardNum++
            if (dashboardNum == 5 && !Dashboard5_On!!) dashboardNum++
            Log.v(TAG, "Button Prev: $dashboardNum")
            if (dashboardNum > 4) dashboardNum = 1
            onPreferencesChangeHandler()
        } else if (v === mBtnNext) {
            dashboardNum--
            Log.v(TAG, "Button Next: $dashboardNum")
            if (dashboardNum < 1) dashboardNum = 4
            if (dashboardNum == 5 && !Dashboard5_On!!) dashboardNum--
            if (dashboardNum == 4 && !Dashboard4_On!!) dashboardNum--
            if (dashboardNum == 3 && !Dashboard3_On!!) dashboardNum--
            if (dashboardNum == 2 && !Dashboard2_On!!) dashboardNum--
            onPreferencesChangeHandler()
        }
    }
    private val mCarStatsListener: CarStatsClient.Listener = object : CarStatsClient.Listener {
        override fun onNewMeasurements(
            provider: String,
            timestamp: Date,
            values: Map<String, Any>
        ) {
            mLastMeasurements.putAll(values)
            postUpdate()

            //Log.i(TAG, "onCarStsuper.onDestroy()atsClient.Listener");
        }

        override fun onSchemaChanged() {
            // do nothing
        }
    }
    private val mVexServiceConnection: ServiceConnection = object : ServiceConnection {
        override fun onServiceConnected(componentName: ComponentName, iBinder: IBinder) {
            val carStatsBinder = iBinder as CarStatsBinder
            statsBound = true
            Log.i(TAG, "ServiceConnected")
            mStatsClient = carStatsBinder.statsClient
            mLastMeasurements = carStatsBinder.statsClient.mergedMeasurements
            carStatsBinder.statsClient.registerListener(mCarStatsListener)
            doUpdate()
        }

        override fun onServiceDisconnected(componentName: ComponentName) {
            statsBound = false
            mStatsClient!!.unregisterListener(mCarStatsListener)
            Log.i(TAG, "ServiceDisconnected")
        }
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        Log.i(TAG, "onAttach")
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.i(TAG, "onCreate")
    }

    private fun updateDisplay() {
        val timer = Timer()
        timer.schedule(object : TimerTask() {
            override fun run() {
                postUpdate()
            }
        }, 0, 500) //Update display 0.5 second
    }

    private fun setupViews(rootView: View?) {
        //layouts/constrains:
        mDashboard_gaudes = rootView!!.findViewById(R.id.include)
        mDashboard_consumption = rootView.findViewById(R.id.include_consumption)
        mConstraintClockLeft = rootView.findViewById(R.id.constraintClockLeft)
        mConstraintClockCenter = rootView.findViewById(R.id.constraintClockCenter)
        mConstraintClockRight = rootView.findViewById(R.id.constraintClockRight)
        mConstraintGraphLeft = rootView.findViewById(R.id.constraintGraphLeft)
        mConstraintGraphCenter = rootView.findViewById(R.id.constraintGraphCenter)
        mConstraintGraphRight = rootView.findViewById(R.id.constraintGraphRight)
        mConstraintElementLeft = rootView.findViewById(R.id.constraintElementLeft)
        mConstraintElementCenter = rootView.findViewById(R.id.constraintElementCenter)
        mConstraintElementRight = rootView.findViewById(R.id.constraintElementRight)
        mConstraintElementLeft?.visibility = View.INVISIBLE
        mConstraintElementCenter?.visibility = View.INVISIBLE
        mConstraintElementRight?.visibility = View.INVISIBLE

        //clocks:
         mClockLeft =rootView.findViewById(R.id.dial_Left)
        mClockCenter = rootView.findViewById(R.id.dial_Center)
        mClockRight = rootView.findViewById(R.id.dial_Right)

        //max & min dials
        mClockMaxLeft = rootView.findViewById(R.id.dial_MaxLeft)
        mClockMaxCenter = rootView.findViewById(R.id.dial_MaxCenter)
        mClockMaxRight = rootView.findViewById(R.id.dial_MaxRight)
        mtextTitleMain = rootView.findViewById(R.id.textTitle)
        //reset value max
        MaxspeedLeft = null
        MaxspeedCenter = null
        MaxspeedRight = null
        MaxspeedLeft = FloatArray(5)
        MaxspeedCenter = FloatArray(5)
        MaxspeedRight = FloatArray(5)
        mBtnNext = rootView.findViewById(R.id.imageButton2)
        mBtnPrev = rootView.findViewById(R.id.imageButton3)

        //graph test
        mGraphLeft = rootView.findViewById(R.id.chart_Left)
        mGraphCenter = rootView.findViewById(R.id.chart_Center)
        mGraphRight = rootView.findViewById(R.id.chart_Right)
        mGraphValueLeft = rootView.findViewById(R.id.graphValueLeft)
        mGraphValueCenter = rootView.findViewById(R.id.graphValueCenter)
        mGraphValueRight = rootView.findViewById(R.id.graphValueRight)
        mSpeedSeriesLeft = LineGraphSeries()
        mSpeedSeriesCenter = LineGraphSeries()
        mSpeedSeriesRight = LineGraphSeries()

        toqueRefresher.populateQuery(
            0,
            TorqueGauge(
                rootView.findViewById(R.id.icon_ClockLeft),
                rootView.findViewById(R.id.rayLeft),
                rootView.findViewById(R.id.textTitleElement),
                rootView.findViewById(R.id.textTitleLabel1),
                rootView.findViewById(R.id.textMaxLeft),
            )
        )

        //icons on the clocks
        mIconClockL = rootView.findViewById(R.id.icon_ClockLeft)
        mIconClockC = rootView.findViewById(R.id.icon_ClockCenter)
        mIconClockR = rootView.findViewById(R.id.icon_ClockRight)

        //ray speedometers for high visibility
        mRayLeft = rootView.findViewById(R.id.rayLeft)
        mRayCenter = rootView.findViewById(R.id.rayCenter)
        mRayRight = rootView.findViewById(R.id.rayRight)

        //the 4 additional dashboard "text" elements:
        mValueElement1 = rootView.findViewById(R.id.value_Element1)
        mValueElement2 = rootView.findViewById(R.id.value_Element2)
        mValueElement3 = rootView.findViewById(R.id.value_Element3)
        mValueElement4 = rootView.findViewById(R.id.value_Element4)

        //title text element
        mTitleElement = rootView.findViewById(R.id.textTitleElement)
        mTitleElementRight = rootView.findViewById(R.id.textTitleElementRight)
        mTitleElementLeft = rootView.findViewById(R.id.textTitleElementLeft)
        mTitleNAVDestinationAddress = rootView.findViewById(R.id.textTitleNAVDestinationAddress)
        mTitleClockLeft = rootView.findViewById(R.id.textTitleLabel1)
        mTitleClockCenter = rootView.findViewById(R.id.textTitleLabel2)
        mTitleClockRight = rootView.findViewById(R.id.textTitleLabel3)
        mTitleConsumptionLeft = rootView.findViewById(R.id.textTitleConsumptionLeft)
        mTitleConsumptionCenter = rootView.findViewById(R.id.textTitleConsumptionCenter)
        mTitleConsumptionRight = rootView.findViewById(R.id.textTitleConsumptionRight)
        mTitleElementNavDistance = rootView.findViewById(R.id.textTitleNavDistance)
        mTitleElementNavTime = rootView.findViewById(R.id.textTitleNavTime)
        mTitleIcon1 = rootView.findViewById(R.id.titleIcon1)
        mTitleIcon2 = rootView.findViewById(R.id.titleIcon2)
        mTitleIcon3 = rootView.findViewById(R.id.titleIcon3)
        mTitleIcon4 = rootView.findViewById(R.id.titleIcon4)
        //labels at these text elements:
        mIconElement1 = rootView.findViewById(R.id.icon_Element1)
        mIconElement2 = rootView.findViewById(R.id.icon_Element2)
        mIconElement3 = rootView.findViewById(R.id.icon_Element3)
        mIconElement4 = rootView.findViewById(R.id.icon_Element4)

        //max texts:
        mTextMaxLeft = rootView.findViewById(R.id.textMaxLeft)
        mTextMaxCenter = rootView.findViewById(R.id.textMaxCenter)
        mTextMaxRight = rootView.findViewById(R.id.textMaxRight)

        //the elements for new dashboard (consumption, service)
        mValueLeftElement1 = rootView.findViewById(R.id.valueLeftElement1)
        mValueLeftElement2 = rootView.findViewById(R.id.valueLeftElement2)
        mValueLeftElement3 = rootView.findViewById(R.id.valueLeftElement3)
        mValueLeftElement4 = rootView.findViewById(R.id.valueLeftElement4)
        mValueLeftElement5 = rootView.findViewById(R.id.valueLeftElement5)
        mValueLeftElement6 = rootView.findViewById(R.id.valueLeftElement6)
        mValueCenterElement1 = rootView.findViewById(R.id.valueCenterElement1)
        mValueCenterElement2 = rootView.findViewById(R.id.valueCenterElement2)
        mValueCenterElement3 = rootView.findViewById(R.id.valueCenterElement3)
        mValueCenterElement4 = rootView.findViewById(R.id.valueCenterElement4)
        mValueCenterElement5 = rootView.findViewById(R.id.valueCenterElement5)
        mValueCenterElement6 = rootView.findViewById(R.id.valueCenterElement6)
        mValueRightElement1 = rootView.findViewById(R.id.valueRightElement1)
        mValueRightElement2 = rootView.findViewById(R.id.valueRightElement2)
        mValueRightElement3 = rootView.findViewById(R.id.valueRightElement3)
        mValueRightElement4 = rootView.findViewById(R.id.valueRightElement4)
        mValueRightElement5 = rootView.findViewById(R.id.valueRightElement5)
        mValueRightElement6 = rootView.findViewById(R.id.valueRightElement6)
        mSteeringWheelAngle = rootView.findViewById(R.id.wheel_angle_image)
        setupListeners()
    }

    private fun setupListeners() {
        //click the
        mGraphLeft!!.setOnClickListener(toggleView)
        mConstraintClockLeft!!.setOnClickListener(toggleView)
        mGraphCenter!!.setOnClickListener(toggleView)
        mConstraintClockCenter!!.setOnClickListener(toggleView)
        mGraphRight!!.setOnClickListener(toggleView)
        mConstraintClockRight!!.setOnClickListener(toggleView)
        mBtnPrev!!.setOnClickListener(toggleView)
        mBtnNext!!.setOnClickListener(toggleView)
    }

    private fun setupTypeface(selectedFont: String?) {
        val assetsMgr = context!!.assets
        var typeface = Typeface.createFromAsset(assetsMgr, "digital.ttf")
        when (selectedFont) {
            "segments" -> typeface = Typeface.createFromAsset(assetsMgr, "digital.ttf")
            "seat" -> typeface =
                Typeface.createFromAsset(assetsMgr, "SEAT_MetaStyle_MonoDigit_Regular.ttf")

            "audi" -> typeface = Typeface.createFromAsset(assetsMgr, "AudiTypeDisplayHigh.ttf")
            "vw" -> typeface = Typeface.createFromAsset(assetsMgr, "VWTextCarUI-Regular.ttf")
            "vw2" -> typeface = Typeface.createFromAsset(assetsMgr, "VWThesis_MIB_Regular.ttf")
            "frutiger" -> typeface = Typeface.createFromAsset(assetsMgr, "Frutiger.otf")
            "vw3" -> typeface = Typeface.createFromAsset(assetsMgr, "VW_Digit_Reg.otf")
            "skoda" -> typeface = Typeface.createFromAsset(assetsMgr, "Skoda.ttf")
            "larabie" -> typeface = Typeface.createFromAsset(assetsMgr, "Larabie.ttf")
            "ford" -> typeface = Typeface.createFromAsset(assetsMgr, "UnitedSans.otf")
        }
        //-------------------------------------------------------------
        //Give them all the right custom typeface
        //clocks
        mClockLeft!!.speedTextTypeface = typeface
        mClockCenter!!.speedTextTypeface = typeface
        mClockRight!!.speedTextTypeface = typeface
        mGraphValueLeft!!.typeface = typeface
        mGraphValueCenter!!.typeface = typeface
        mGraphValueRight!!.typeface = typeface
        //elements
        mValueElement1!!.typeface = typeface
        mValueElement2!!.typeface = typeface
        mValueElement3!!.typeface = typeface
        mValueElement4!!.typeface = typeface
        mIconElement1!!.typeface = typeface
        mIconElement2!!.typeface = typeface
        mIconElement3!!.typeface = typeface
        mIconElement4!!.typeface = typeface
        mTitleElement!!.typeface = typeface
        mTitleElementRight!!.typeface = typeface
        mTitleElementLeft!!.typeface = typeface
        mTitleNAVDestinationAddress!!.typeface = typeface
        mTitleClockLeft!!.typeface = typeface
        mTitleClockCenter!!.typeface = typeface
        mTitleClockRight!!.typeface = typeface
        mTitleConsumptionLeft!!.typeface = typeface
        mTitleConsumptionCenter!!.typeface = typeface
        mTitleConsumptionRight!!.typeface = typeface
        mTitleElementNavDistance!!.typeface = typeface
        mTitleElementNavTime!!.typeface = typeface
        mtextTitleMain!!.typeface = typeface

        //max
        mTextMaxLeft!!.typeface = typeface
        mTextMaxCenter!!.typeface = typeface
        mTextMaxRight!!.typeface = typeface
        Log.d(TAG, "font: $typeface")
        this.selectedFont = selectedFont
    }

    private fun onPreferencesChangeHandler() {
        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(
            context
        )
        ambientOn = sharedPreferences.getBoolean(
            "ambientActive",
            false
        ) //true = use ambient colors, false = don't use.
        accurateOn = sharedPreferences.getBoolean(
            "accurateActive",
            false
        ) //true = be accurate. false = have 2000ms of animation time
        proximityOn = sharedPreferences.getBoolean(
            "proximityActive",
            false
        ) //true = be accurate. false = have 2000ms of animation time
        updateSpeed = if (accurateOn!!) {
            1
        } else {
            2000
        }
        if (!proximityOn!!) {
            mBtnNext!!.visibility = View.VISIBLE
            mBtnPrev!!.visibility = View.VISIBLE
            mtextTitleMain!!.visibility = View.VISIBLE
        }

        // Load this only on first run, then leave it alone
        if (stagingDone == null) {
            stagingDone = !sharedPreferences.getBoolean("stagingActive", true)
        }
        showStreetName = sharedPreferences.getBoolean("showStreetNameInTitle", true)
        useGoogleGeocoding = sharedPreferences.getBoolean("useGoogleGeocoding", false)
        forceGoogleGeocoding = sharedPreferences.getBoolean("forceGoogleGeocoding", false)
        sourceLocation = sharedPreferences.getString("locationSourceData", "Geocoding")
        fueltanksize = sharedPreferences.getString("fueltanksize", "50")!!.toFloat()
        val speedLeft = MaxspeedLeft!![dashboardNum]
        val speedCenter = MaxspeedCenter!![dashboardNum]
        val speedRight = MaxspeedRight!![dashboardNum]
        mClockMaxLeft!!.speedTo(speedLeft)
        mClockMaxCenter!!.speedTo(speedCenter)
        mClockMaxRight!!.speedTo(speedRight)
        mTextMaxLeft!!.text = String.format(
            Locale.US,
            FORMAT_DECIMALS,
            speedLeft
        )
        mTextMaxCenter!!.text = String.format(
            Locale.US,
            FORMAT_DECIMALS,
            speedCenter
        )
        mTextMaxRight!!.text = String.format(
            Locale.US,
            FORMAT_DECIMALS,
            speedRight
        )
        val dashboardId = dashboardNum.toString()
        val mtextTitlePerformance: String?
        mtextTitlePerformance = if (dashboardNum < 4) {
            sharedPreferences.getString(
                "performanceTitle$dashboardId",
                "Performance monitor$dashboardId"
            )
        } else {
            resources.getString(R.string.pref_title_performance_4)
        }
        mtextTitleMain!!.text = mtextTitlePerformance
        val readedBackground =
            sharedPreferences.getString("selectedBackground", "background_incar_black")
        if (readedBackground != selectedBackground) {
            setupBackground(readedBackground)
        }
        val readedFont = sharedPreferences.getString("selectedFont", "segments")
        if (readedBackground != selectedFont) {
            setupTypeface(readedFont)
        }

        //show high visible rays on, according to the setting
        val readedRaysOn = sharedPreferences.getBoolean(
            "highVisActive",
            false
        ) //true = show high vis rays, false = don't show them.
        if (raysOn == null || readedRaysOn != raysOn) {
            raysOn = readedRaysOn
            turnRaysEnabled(raysOn!!)
        }
        val readedTheme = sharedPreferences.getString("selectedTheme", "")
        if (readedTheme != selectedTheme) {
            selectedTheme = readedTheme
            turnRaysEnabled(raysOn!!)
        }
        val readedTicksOn = sharedPreferences.getBoolean(
            "ticksActive",
            false
        ) // if true, it will display the value of each of the ticks
        if (ticksOn == null || readedTicksOn != ticksOn) {
            ticksOn = readedTicksOn
            turnTickEnabled(ticksOn!!)
        }

        //determine what data the user wants to have on the 4 data views
        val readedElement1Query = sharedPreferences.getString("selectedView1_$dashboardId", "none")
        if (readedElement1Query != mElement1Query) {
            mElement1Query = readedElement1Query
            setupElement(mElement1Query, mValueElement1, mIconElement1)
        }
        val readedElement2Query = sharedPreferences.getString("selectedView2_$dashboardId", "none")
        if (readedElement2Query != mElement2Query) {
            mElement2Query = readedElement2Query
            setupElement(mElement2Query, mValueElement2, mIconElement2)
        }
        val readedElement3Query = sharedPreferences.getString("selectedView3_$dashboardId", "none")
        if (readedElement3Query != mElement3Query) {
            mElement3Query = readedElement3Query
            setupElement(mElement3Query, mValueElement3, mIconElement3)
        }
        val readedElement4Query = sharedPreferences.getString("selectedView4_$dashboardId", "none")
        if (readedElement4Query != mElement4Query) {
            mElement4Query = readedElement4Query
            setupElement(mElement4Query, mValueElement4, mIconElement4)
        }
        //determine what data the user wants to have on the 3 clocks, but set defaults first
        //setup clocks, including the max/min clocks and highvis rays and icons:
        //usage: setupClocks(query value, what clock, what icon, which ray, which min clock, which max clock)
        //could probably be done MUCH more efficient but that's for the future ;)
        val readedClockLQuery =
            sharedPreferences.getString("selectedClockLeft$dashboardId", "exlap-batteryVoltage")
        if (readedClockLQuery != mClockLQuery) {
            mClockLQuery = readedClockLQuery
            setupClocks(mClockLQuery, mClockLeft, mIconClockL, mRayLeft, mClockMaxLeft)
            turnTickEnabled(ticksOn!!) // Due to bug in SpeedView, we need to re-enable ticks
        }
        val readedClockCQuery =
            sharedPreferences.getString("selectedClockCenter$dashboardId", "exlap-oilTemperature")
        if (readedClockCQuery != mClockCQuery) {
            mClockCQuery = readedClockCQuery
            setupClocks(mClockCQuery, mClockCenter, mIconClockC, mRayCenter, mClockMaxCenter)
            turnTickEnabled(ticksOn!!) // Due to bug in SpeedView, we need to re-enable ticks
        }
        val readedClockRQuery =
            sharedPreferences.getString("selectedClockRight$dashboardId", "exlap-engineSpeed")
        if (readedClockRQuery != mClockRQuery) {
            mClockRQuery = readedClockRQuery
            setupClocks(mClockRQuery, mClockRight, mIconClockR, mRayRight, mClockMaxRight)
            turnTickEnabled(ticksOn!!) // Due to bug in SpeedView, we need to re-enable ticks
        }
        //debug logging of each of the chosen elements
        Log.d(TAG, "element 1 selected:$mElement1Query")
        Log.d(TAG, "element 2 selected:$mElement2Query")
        Log.d(TAG, "element 3 selected:$mElement3Query")
        Log.d(TAG, "element 4 selected:$mElement4Query")
        Log.d(TAG, "clock l selected:$mClockLQuery")
        Log.d(TAG, "clock c selected:$mClockCQuery")
        Log.d(TAG, "clock r selected:$mClockRQuery")

        //determine what data the user wants to have on the 4 data views
        mLabelClockL = getLabelClock(mClockLQuery)
        mLabelClockC = getLabelClock(mClockCQuery)
        mLabelClockR = getLabelClock(mClockRQuery)
        val readedPressureUnits =
            sharedPreferences.getBoolean("selectPressureUnit", true) //true = bar, false = psi
        if (readedPressureUnits != selectedPressureUnits) {
            selectedPressureUnits = readedPressureUnits
            pressureFactor = if (selectedPressureUnits) 1f else 14.503774f
            pressureUnit = if (selectedPressureUnits) "bar" else "psi"
            pressureMin = if (selectedPressureUnits) -3 else -30
            pressureMax = if (selectedPressureUnits) 3 else 30
        }
        val readedTempUnit = sharedPreferences.getBoolean(
            "selectTemperatureUnit",
            true
        ) //true = celcius, false = fahrenheit
        celsiusTempUnit = readedTempUnit
        temperatureUnit = getString(if (celsiusTempUnit) R.string.unit_c else R.string.unit_f)
        val readedPowerUnits =
            sharedPreferences.getBoolean("selectPowerUnit", true) //true = kw, false = ps
        if (TorqueData.powerUnits == null || readedPowerUnits != TorqueData.powerUnits) {
            TorqueData.powerUnits = readedPowerUnits
            powerFactor = if (TorqueData.powerUnits!!) 1f else 1.35962f
        }
        //

        //show texts and backgrounds for max/min, according to the setting
        val readedMaxOn = sharedPreferences.getBoolean(
            "maxValuesActive",
            false
        ) //true = show max values, false = hide them
        if (maxOn == null || readedMaxOn != maxOn) {
            maxOn = readedMaxOn
            turnMinMaxTextViewsEnabled(maxOn!!)
        }
        val readedMaxMarksOn = sharedPreferences.getBoolean(
            "maxMarksActive",
            false
        ) //true = show max values as a mark on the clock, false = hide them
        if (maxMarksOn == null || readedMaxMarksOn != maxMarksOn) {
            maxMarksOn = readedMaxMarksOn
            turnMinMaxMarksEnabled(maxMarksOn!!)
        }
    }

    private fun setupBackground(newBackground: String?) {
        val resId = resources.getIdentifier(newBackground, "drawable", context!!.packageName)
        if (resId != 0) {
            val wallpaperImage = ContextCompat.getDrawable(context!!, resId)
            rootView!!.background = wallpaperImage
        }
        selectedBackground = newBackground
    }

    private val preferenceChangeListener =
        OnSharedPreferenceChangeListener { sharedPreferences, key -> onPreferencesChangeHandler() }

    private fun turnMinMaxMarksEnabled(enabled: Boolean) {
        //show clock marks for max/min, according to the setting
        mClockMaxLeft!!.visibility =
            if (enabled) View.VISIBLE else View.INVISIBLE
        mClockMaxCenter!!.visibility = if (enabled) View.VISIBLE else View.INVISIBLE
        mClockMaxRight!!.visibility = if (enabled) View.VISIBLE else View.INVISIBLE
    }

    private fun turnMinMaxTextViewsEnabled(enabled: Boolean) {
        mTextMaxLeft!!.visibility =
            if (enabled) View.VISIBLE else View.INVISIBLE
        mTextMaxCenter!!.visibility =
            if (enabled) View.VISIBLE else View.INVISIBLE
        mTextMaxRight!!.visibility =
            if (enabled) View.VISIBLE else View.INVISIBLE
    }

    private fun turnRaysEnabled(enabled: Boolean) {
        mRayLeft!!.visibility = if (enabled) View.VISIBLE else View.INVISIBLE
        mRayCenter!!.visibility =
            if (enabled) View.VISIBLE else View.INVISIBLE
        mRayRight!!.visibility = if (enabled) View.VISIBLE else View.INVISIBLE
        if (enabled) {
            //also hide the needle on the clocks
            mClockLeft!!.setIndicator(Indicators.NoIndicator)
            mClockCenter!!.setIndicator(Indicators.NoIndicator)
            mClockRight!!.setIndicator(Indicators.NoIndicator)
        } else {
            setupIndicators()
        }
    }

    private fun turnTickEnabled(enabled: Boolean) {
        val tickNum = 9
        mClockLeft!!.tickNumber = if (enabled) tickNum else 0
        mClockLeft!!.textColor = Color.WHITE
        mClockCenter!!.tickNumber = if (enabled) tickNum else 0
        mClockCenter!!.textColor = Color.WHITE
        mClockRight!!.tickNumber = if (enabled) tickNum else 0
        mClockRight!!.textColor = Color.WHITE
    }

    private fun setupIndicators() {
        var clockSize = mClockLeft!!.height
        if (clockSize == 0) {
            clockSize = 250
        }
        //this is to enable an image as indicator.
        val typedArray = context!!.theme.obtainStyledAttributes(intArrayOf(R.attr.themedNeedle))
        val resourceId = typedArray.getResourceId(0, 0)
        typedArray.recycle()
        val imageIndicator = ImageIndicator(context!!, resourceId, clockSize, clockSize)
        val color = mClockLeft!!.indicatorColor
        Log.i(TAG, "IndicatorColor: $color")
        if (color == 1996533487) {       // if indicator color in the style is @color:aqua, make it an imageindicator
            mClockLeft!!.setIndicator(imageIndicator)
            mClockCenter!!.setIndicator(imageIndicator)
            mClockRight!!.setIndicator(imageIndicator)
            mClockLeft!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mClockCenter!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mClockRight!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayLeft!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayRight!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayCenter!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
        } else {
            //mClockLeft.setIndicator(Indicator.Indicators.HalfLineIndicator);
            //mClockCenter.setIndicator(Indicator.Indicators.HalfLineIndicator);
            //mClockRight.setIndicator(Indicator.Indicators.HalfLineIndicator);

            // do something to get the other type of indicator
        }

        // if rays on, turn off everything else.
        // it doesn't look too efficient at the moment, but that's to prevent the theme from adding an indicator to the rays.
        if (raysOn!!) {
            // todo: move this to setupClock
            mClockLeft!!.setIndicator(Indicators.NoIndicator)
            mClockCenter!!.setIndicator(Indicators.NoIndicator)
            mClockRight!!.setIndicator(Indicators.NoIndicator)
            mRayLeft!!.setIndicator(Indicators.NoIndicator)
            mRayRight!!.setIndicator(Indicators.NoIndicator)
            mRayCenter!!.setIndicator(Indicators.NoIndicator)

            //make indicatorlight color transparent if you don't need it:
            mClockLeft!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mClockCenter!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mClockRight!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            //
            mRayLeft!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayRight!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayCenter!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
        } else if (color == -14575885) {
            //if theme has transparent indicator color, give clocks a custom image indicator
            //todo: do this on other fragments as well
            mClockLeft!!.setIndicator(imageIndicator)
            mClockCenter!!.setIndicator(imageIndicator)
            mClockRight!!.setIndicator(imageIndicator)
            mClockLeft!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mClockCenter!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mClockRight!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayLeft!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayRight!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
            mRayCenter!!.indicatorLightColor = Color.parseColor("#00FFFFFF")
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        Log.i(TAG, "onCreateView")
        rootView = inflater.inflate(R.layout.fragment_dashboard, container, false)
        setupViews(rootView)
        onPreferencesChangeHandler()

        //Get preferences
        //set pressure dial to the wanted units
        //Most bar dials go from -2 to 3 bar.
        //Most PSI dials go from -30 to 30 psi.
        //pressurefactor is used to calculate the right value for psi later
        // build ImageIndicator using the resourceId
        // get the size of the Clock, to make sure the imageindicator has the right size.
        mClockLeft!!.viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener {
            override fun onGlobalLayout() {
                mClockLeft!!.viewTreeObserver.removeOnGlobalLayoutListener(this)
                setupIndicators()
                setupGraph(mClockLeft, mGraphLeft, mSpeedSeriesLeft, mConstraintGraphLeft)
                setupGraph(mClockCenter, mGraphCenter, mSpeedSeriesCenter, mConstraintGraphCenter)
                setupGraph(mClockRight, mGraphRight, mSpeedSeriesRight, mConstraintGraphRight)
                turnTickEnabled(ticksOn!!)
                runStagingAnimation()
            }
        })
        androidClockFormat = if (DateFormat.is24HourFormat(context)) "HH:mm" else "hh:mm a"

        //update!
        doUpdate()
        return rootView
    }

    private fun getLabelClock(queryClock: String?): String {
        var mtext = ""
        if (queryClock != null && queryClock != "") {
            val valueArray = resources.getStringArray(R.array.ClockDataElementsValues)
            val stringArray = resources.getStringArray(R.array.ClockDataElementsEntries)
            val lindex = Arrays.asList(*valueArray).indexOf(queryClock)
            if (lindex >= 0) {
                mtext = stringArray[lindex]
            }
        }
        return mtext
    }

    private fun runStagingAnimation() {
        if (!stagingDone!!) {
            mClockLeft!!.speedPercentTo(100, 1000)
            mClockCenter!!.speedPercentTo(100, 1000)
            mClockRight!!.speedPercentTo(100, 1000)
            mRayLeft!!.speedPercentTo(100, 1000)
            mRayCenter!!.speedPercentTo(100, 1000)
            mRayRight!!.speedPercentTo(100, 1000)
            val staging = Handler()
            staging.postDelayed({
                if (mClockLeft != null) {
                    mClockLeft!!.speedTo(0f, 1000)
                    mClockCenter!!.speedTo(0f, 1000)
                    mClockRight!!.speedTo(0f, 1000)
                    mRayLeft!!.speedTo(0f, 1000)
                    mRayCenter!!.speedTo(0f, 1000)
                    mRayRight!!.speedTo(0f, 1000)
                }
            }, 1700)
            val stagingReset = Handler()
            stagingReset.postDelayed({
                if (mClockLeft != null) {
                    mClockMaxLeft!!.speedTo(mClockLeft!!.speed, 1000)
                    mClockMaxCenter!!.speedTo(mClockCenter!!.speed, 1000)
                    mClockMaxRight!!.speedTo(mClockRight!!.speed, 1000)
                    mTextMaxLeft!!.text = "-"
                    mTextMaxCenter!!.text = "-"
                    mTextMaxRight!!.text = "-"
                    stagingDone = true
                }
            }, 2700)
        }
    }

    private val onNoticeGoogleNavigationUpdate: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            //String text = intent.getStringExtra("text"); // Not used right now
            googleMapsLocationStr = intent.getStringExtra("title")
        }
    }
    private val onNoticeGoogleNavigationClosed: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            googleMapsLocationStr = null
        }
    }

    override fun onStart() {
        super.onStart()
        Log.i(TAG, "onStart")
    }

    override fun onResume() {
        super.onResume()
        Log.i(TAG, "onActivate")
        val serviceIntent = Intent(context, CarStatsService::class.java)
        context!!.bindService(serviceIntent, mVexServiceConnection, Context.BIND_AUTO_CREATE)
        startTorque()
        createAndStartUpdateTimer()
        if (useGoogleGeocoding) {
            if (!context!!.bindService(
                    Intent(context, GeocodeLocationService::class.java),
                    mGeocodingServiceConnection,
                    Context.BIND_AUTO_CREATE
                )
            ) {
                Log.e("Geocode", "Cannot bind?!")
            }
        }
        LocalBroadcastManager.getInstance(context!!)
            .registerReceiver(
                onNoticeGoogleNavigationUpdate,
                IntentFilter("GoogleNavigationUpdate")
            )
        LocalBroadcastManager.getInstance(context!!)
            .registerReceiver(
                onNoticeGoogleNavigationClosed,
                IntentFilter("GoogleNavigationClosed")
            )
        PreferenceManager.getDefaultSharedPreferences(context)
            .registerOnSharedPreferenceChangeListener(preferenceChangeListener)
        onPreferencesChangeHandler()
        // Force reload of components
        turnRaysEnabled(raysOn!!)
        turnMinMaxTextViewsEnabled(maxOn!!)
        turnMinMaxMarksEnabled(maxMarksOn!!)
        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(
            context
        )
        Dashboard2_On = sharedPreferences.getBoolean("d2_active", false) //Enabled dasboard2.
        Dashboard3_On = sharedPreferences.getBoolean("d3_active", false) //Enabled dasboard3
        Dashboard4_On = sharedPreferences.getBoolean("d4_active", false) //Enabled dasboard4
        //Dashboard5_On = sharedPreferences.getBoolean("d5_active", false);  //Enabled dasboard5
        Dashboard5_On = false
    }

    private val geocodeResultListener = IGeocodeResult { result ->
        val sb = StringBuilder()
        var tmp = result.thoroughfare
        if (tmp != null) sb.append(tmp)
        if (sb.length != 0) sb.append(", ")
        tmp = result.subAdminArea //Town
        if (tmp != null) sb.append(tmp)
        sb.append(' ')
        //    tmp = result.getPostalCode();  //PostalCode
        //    if (tmp != null)
        //        sb.append("("+tmp+")");
        tmp = result.url //URL -> Altitude
        if (tmp != null) sb.append("($tmp)")
        googleGeocodeLocationStr = sb.toString()
    }
    private val mGeocodingServiceConnection: ServiceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName, service: IBinder) {
            mGeocodingService = (service as LocalBinder).service
            service.service.setOnNewGeocodeListener(geocodeResultListener)
            Log.d("Geocode", "Service connected")
        }

        override fun onServiceDisconnected(name: ComponentName) {
            Log.e("Geocode", "Service disconnected")
            mGeocodingService = null
        }
    }

    private fun startTorque() {
        val intent = Intent()
        intent.setClassName("org.prowl.torque", "org.prowl.torque.remote.TorqueService")
        val torqueBind = context!!.bindService(intent, torqueConnection, Activity.BIND_AUTO_CREATE)
        Log.d(
            TAG,
            if (torqueBind) "Connected to torque service!" else "Unable to connect to Torque plugin service"
        )
    }

    private fun stopTorque() {
        context!!.sendBroadcast(Intent("org.prowl.torque.REQUEST_TORQUE_QUIT"))
        Log.d(TAG, "Torque stop")
    }

    private fun createAndStartUpdateTimer() {
        updateTimer = Timer()
        updateTimer!!.schedule(object : TimerTask() {
            override fun run() {
                val updateTimerRunnable = Runnable { doUpdate() }
                //experimental delay
                mHandler?.postDelayed(updateTimerRunnable, 1)
            }
        }, 0, 250) //Update display 0,25 second
    }

    override fun onPause() {
        Log.i(TAG, "onDeactivate")
        updateTimer!!.cancel()
        mStatsClient!!.unregisterListener(mCarStatsListener)
        if (statsBound) {
            context!!.unbindService(mVexServiceConnection)
        }
        if (useGoogleGeocoding) {
            context!!.unbindService(mGeocodingServiceConnection)
        }
        if (torqueBind) try {
            context!!.unbindService(torqueConnection)
        } catch (E: Exception) {
            throw E
        }
        LocalBroadcastManager.getInstance(context!!)
            .unregisterReceiver(onNoticeGoogleNavigationUpdate)
        LocalBroadcastManager.getInstance(context!!)
            .unregisterReceiver(onNoticeGoogleNavigationClosed)
        PreferenceManager.getDefaultSharedPreferences(context)
            .unregisterOnSharedPreferenceChangeListener(preferenceChangeListener)
        super.onPause()
    }

    override fun onDestroyView() {
        Log.i(TAG, "onDestroyView")

        //put things back to null.
        //todo: check if this list is complete (probably some things are still missing)
        mClockLeft = null
        mClockCenter = null
        mClockRight = null
        mSteeringWheelAngle = null
        mValueElement1 = null
        mValueElement2 = null
        mValueElement3 = null
        mValueElement4 = null
        mTitleElement = null
        mTitleElementRight = null
        mTitleElementLeft = null
        mTitleNAVDestinationAddress = null
        mTitleClockLeft = null
        mTitleClockCenter = null
        mTitleClockRight = null
        mTitleConsumptionLeft = null
        mTitleConsumptionCenter = null
        mTitleConsumptionRight = null
        mTitleElementNavDistance = null
        mTitleElementNavTime = null
        mTitleIcon1 = null
        mTitleIcon2 = null
        mTitleIcon3 = null
        mTitleIcon4 = null
        mIconElement1 = null
        mIconElement2 = null
        mIconElement3 = null
        mIconElement4 = null
        mElement1Query = null
        mElement2Query = null
        mElement3Query = null
        mElement4Query = null
        mClockLQuery = null
        mClockCQuery = null
        mClockRQuery = null
        mIconClockL = null
        mIconClockC = null
        mIconClockR = null
        mClockMaxLeft = null
        mClockMaxCenter = null
        mClockMaxRight = null
        mRayLeft = null
        mRayCenter = null
        mRayRight = null
        selectedFont = null
        pressureUnit = null
        //stagingDone = false;
        mGraphCenter = null
        mGraphLeft = null
        mGraphRight = null
        mSpeedSeriesCenter = null
        mSpeedSeriesLeft = null
        mSpeedSeriesRight = null
        mConstraintClockLeft = null
        mConstraintClockRight = null
        mConstraintClockCenter = null
        mConstraintGraphLeft = null
        mConstraintGraphRight = null
        mConstraintGraphCenter = null
        mConstraintElementLeft = null
        mConstraintElementRight = null
        mConstraintElementCenter = null
        mGraphValueLeft = null
        mGraphValueCenter = null
        mGraphValueRight = null
        super.onDestroyView()
    }

    override fun onStop() {
        Log.i(TAG, "onStop")
        stopTorque()
        super.onStop()
    }

    override fun onDetach() {
        Log.i(TAG, "onDetach")
        super.onDetach()
    }

    override fun onDestroy() {
        Log.i(TAG, "onDestroy")
        super.onDestroy()
    }

    private var lastUpdate: Long = -1
    private fun postUpdate() {
        if (lastUpdate < 0 || System.currentTimeMillis() - lastUpdate > UPDATE_AFTER) {
            lastUpdate = System.currentTimeMillis()
            mHandler!!.post { doUpdate() }
        }
    }

    private fun SetLayoutElements(
        mValueElement: TextView?,
        mMeasurements: String?,
        mUnit: String?,
        mDefUnit: String,
        mFormat: String
    ) {
        var mGetMeasurement: Float?
        var mGetUnit: String?
        if (mMeasurements == null || mMeasurements.isEmpty()) {
            mValueElement!!.text = ""
        } else {
            mGetMeasurement = mLastMeasurements[mMeasurements] as Float?
            if (mGetMeasurement == null) mGetMeasurement = java.lang.Float.valueOf(0f)
            if (mMeasurements === "tankLevelPrimary") mGetMeasurement =
                mGetMeasurement!! * fueltanksize
            if (mMeasurements === "driving distance") {
                mGetMeasurement = mLastMeasurements["tankLevelPrimary"] as Float?
                if (mGetMeasurement == null) mGetMeasurement = java.lang.Float.valueOf(0f)
                mGetMeasurement = mGetMeasurement!! * fueltanksize
                val mShortCons = mLastMeasurements["shortTermConsumptionPrimary"] as Float?
                val mLongCons = mLastMeasurements["LongTermConsumptionPrimary"] as Float?
                mGetMeasurement = if (mShortCons == null || mShortCons == 0f) {
                    if (mLongCons == null || mLongCons == 0f) {
                        java.lang.Float.valueOf(0f)
                    } else {
                        mGetMeasurement / mLongCons * 100
                    }
                } else {
                    mGetMeasurement / mShortCons * 100
                }
            }
            if (mUnit == null || mUnit.isEmpty()) {
                mGetUnit = mDefUnit
            } else {
                mGetUnit = mLastMeasurements[mUnit] as String?
                if (mGetUnit == null || mGetUnit.isEmpty()) {
                    mGetUnit = mDefUnit
                }
            }
            if (mFormat === "FORMAT_SHORTTIME") {
                mValueElement!!.text = ConvertMinutesTime(
                    mGetMeasurement!!.toInt()
                ) + " " + mGetUnit
            } else {
                mValueElement!!.text = String.format(mFormat, mGetMeasurement) + " " + mGetUnit
            }
        }
    }

    private fun UpdateLayoutElements() {
        //Left elements
        SetLayoutElements(
            mValueLeftElement1,
            "consumptionShortTermGeneral.distanceValue",
            "consumptionShortTermGeneral.distanceUnit",
            "km",
            FORMAT_DECIMALS
        )
        SetLayoutElements(
            mValueLeftElement2,
            "consumptionShortTermGeneral.speedValue",
            "consumptionShortTermGeneral.speedUnit",
            "km/h",
            FORMAT_DECIMALS
        )
        SetLayoutElements(
            mValueLeftElement3,
            "consumptionShortTermGeneral.time",
            "",
            "",
            "FORMAT_SHORTTIME"
        )
        SetLayoutElements(mValueLeftElement5, "", "", "", FORMAT_DECIMALS)
        SetLayoutElements(mValueLeftElement5, "", "", "", FORMAT_DECIMALS)
        SetLayoutElements(
            mValueLeftElement6,
            "shortTermConsumptionPrimary",
            "shortTermConsumptionPrimary.unit",
            "l/100km",
            FORMAT_DECIMALS
        )

        //Center elements
        SetLayoutElements(
            mValueCenterElement1,
            "consumptionLongTermGeneral.distanceValue",
            "consumptionLongTermGeneral.distanceUnit",
            "km",
            FORMAT_DECIMALS
        )
        SetLayoutElements(
            mValueCenterElement2,
            "consumptionLongTermGeneral.speedValue",
            "consumptionLongTermGeneral.speedUnit",
            "km/h",
            FORMAT_DECIMALS
        )
        SetLayoutElements(
            mValueCenterElement3,
            "consumptionLongTermGeneral.time",
            "",
            "",
            "FORMAT_SHORTTIME"
        )
        SetLayoutElements(mValueCenterElement5, "", "", "", FORMAT_DECIMALS)
        SetLayoutElements(mValueCenterElement5, "", "", "", FORMAT_DECIMALS)
        SetLayoutElements(
            mValueCenterElement6,
            "longTermConsumptionPrimary",
            "longTermConsumptionPrimary.unit",
            "l/100km",
            FORMAT_DECIMALS
        )

        //Right elements
        SetLayoutElements(mValueRightElement1, "tankLevelPrimary", "", "l", FORMAT_DECIMALS)
        SetLayoutElements(
            mValueRightElement2,
            "driving distance",
            "consumptionShortTermGeneral.distanceUnit",
            "km",
            FORMAT_NO_DECIMALS
        )
        SetLayoutElements(mValueRightElement3, "", "", "", "")
        SetLayoutElements(mValueRightElement5, "", "", "", FORMAT_DECIMALS)
        SetLayoutElements(mValueRightElement5, "", "", "", FORMAT_DECIMALS)
        SetLayoutElements(
            mValueRightElement6,
            "currentConsumptionPrimary",
            "currentConsumptionPrimary.unit",
            "l/100km",
            FORMAT_DECIMALS
        )
    }

    private fun doUpdate() {
        if (mClockLeft == null) {
            return
        }

        //wait until staging is done before displaying any data on the clocks.
        if (!stagingDone!!) {
            Log.d(TAG, "Staging not done yet")
            return
        }
        // Update Title - always!!!
        updateTitle()

        // Visiblle layout_dashboard_gauges or layouu_dashboard_consumption
        if (dashboardNum < 4) {
            // settings
            mConstraintElementLeft!!.visibility = View.INVISIBLE
            mConstraintElementCenter!!.visibility = View.INVISIBLE
            mConstraintElementRight!!.visibility = View.INVISIBLE
            mConstraintClockLeft!!.visibility = View.VISIBLE
            mConstraintClockCenter!!.visibility = View.VISIBLE
            mConstraintClockRight!!.visibility = View.VISIBLE

            torqueService.let { v ->
                if (v != null) {
                    toqueRefresher.refreshQueries(v)
                }
            }

            //update each of the elements:
            updateElement(mElement1Query, mValueElement1, mIconElement1)
            updateElement(mElement2Query, mValueElement2, mIconElement2)
            updateElement(mElement3Query, mValueElement3, mIconElement3)
            updateElement(mElement4Query, mValueElement4, mIconElement4)

            //update each of the clocks and the min/max/ray elements that go with it
            // query, dial, visray, textmax, textmin, clockmax, clockmin)
            updateClock(
                mClockLQuery,
                mClockLeft,
                mRayLeft,
                mTextMaxLeft,
                mClockMaxLeft,
                mGraphLeft,
                mSpeedSeriesLeft,
                graphLeftLastXValue,
                mGraphValueLeft,
                MaxspeedLeft
            )
            updateClock(
                mClockCQuery,
                mClockCenter,
                mRayCenter,
                mTextMaxCenter,
                mClockMaxCenter,
                mGraphCenter,
                mSpeedSeriesCenter,
                graphCenterLastXValue,
                mGraphValueCenter,
                MaxspeedCenter
            )
            updateClock(
                mClockRQuery,
                mClockRight,
                mRayRight,
                mTextMaxRight,
                mClockMaxRight,
                mGraphRight,
                mSpeedSeriesRight,
                graphRightLastXValue,
                mGraphValueRight,
                MaxspeedRight
            )


            // get ambient color, change color of some elements to match the ambient color.
            // this can't be done during setup, because then the ambientColor is probably not received yet.
            if (ambientOn!!) {
                val ambientColor =
                    if (mLastMeasurements.containsKey("Car_ambienceLightColour.ColourSRGB")) mLastMeasurements["Car_ambienceLightColour.ColourSRGB"] as String? else null
                //ambientColor = "#FF0000"; // for testing purposes
                if (ambientColor != null && ambientColor != "") {
                    val parsedColor = Color.parseColor(ambientColor)
                    if (parsedColor != mClockLeft!!.indicatorColor || parsedColor != mRayLeft!!.getLowSpeedColor()) {
                        if (raysOn!!) {
                            mRayLeft!!.setLowSpeedColor(parsedColor)
                            mRayCenter!!.setLowSpeedColor(parsedColor)
                            mRayRight!!.setLowSpeedColor(parsedColor)
                            mRayLeft!!.setMediumSpeedColor(parsedColor)
                            mRayCenter!!.setMediumSpeedColor(parsedColor)
                            mRayRight!!.setMediumSpeedColor(parsedColor)
                        } else {
                            mClockLeft!!.indicatorColor = parsedColor
                            mClockCenter!!.indicatorColor = parsedColor
                            mClockRight!!.indicatorColor = parsedColor
                            mClockLeft!!.indicatorLightColor = parsedColor
                            mClockCenter!!.indicatorLightColor = parsedColor
                            mClockRight!!.indicatorLightColor = parsedColor
                        }
                        when (selectedBackground) {
                            "background_incar_dots", "background_incar_skoda2" -> {
                                val resId = resources.getIdentifier(
                                    selectedBackground,
                                    "drawable",
                                    context!!.packageName
                                )
                                val wallpaperImage = ContextCompat.getDrawable(context!!, resId)
                                wallpaperImage!!.colorFilter =
                                    LightingColorFilter(parsedColor, Color.parseColor("#010101"))
                                rootView!!.background = wallpaperImage
                            }
                        }
                    }
                }
            }
        } else {
            mConstraintElementLeft!!.visibility = View.VISIBLE
            mConstraintElementCenter!!.visibility = View.VISIBLE
            mConstraintElementRight!!.visibility = View.VISIBLE
            mConstraintClockLeft!!.visibility = View.INVISIBLE
            mConstraintClockCenter!!.visibility = View.INVISIBLE
            mConstraintClockRight!!.visibility = View.INVISIBLE
            UpdateLayoutElements()
        }

        // wheel angle monitor
        val currentWheelAngle = mLastMeasurements["wheelAngle"] as Float?
        mSteeringWheelAngle!!.rotation = if (currentWheelAngle == null) 0.0f else Math.min(
            Math.max(-WheelStateMonitor.WHEEL_CENTER_THRESHOLD_DEG, -currentWheelAngle),
            WheelStateMonitor.WHEEL_CENTER_THRESHOLD_DEG
        )
        mSteeringWheelAngle!!.visibility = View.INVISIBLE
    }

    private fun setupGraph(
        clock: Speedometer?,
        graph: GraphView?,
        serie: LineGraphSeries<DataPoint>?,
        constraint: ConstraintLayout?
    ) {
        val typedArray =
            context!!.theme.obtainStyledAttributes(intArrayOf(R.attr.themedBlankDialBackground))
        val blankBackgroundResource = typedArray.getResourceId(0, 0)
        typedArray.recycle()
        graph!!.addSeries(serie)
        graph.title = clock!!.getUnit()
        constraint!!.setBackgroundResource(blankBackgroundResource) // put blank background
        serie!!.setAnimated(true)
        graph.elevation = 55f
        val graphViewport = graph.viewport
        val gridLabelRenderer = graph.gridLabelRenderer
        graphViewport.isXAxisBoundsManual = true
        graphViewport.isYAxisBoundsManual = true
        graphViewport.setMinX(0.0)
        // set default max and min, these will be set dynamically later
        graphViewport.setMaxX(120.0)
        graphViewport.isScrollable = false
        gridLabelRenderer.isVerticalLabelsVisible = true
        gridLabelRenderer.isHighlightZeroLines = false
        gridLabelRenderer.gridColor = Color.parseColor("#22FFFFFF")
        gridLabelRenderer.verticalLabelsColor = Color.parseColor("#22FFFFFF")
        gridLabelRenderer.isHorizontalLabelsVisible = false
        gridLabelRenderer.gridStyle = GridLabelRenderer.GridStyle.HORIZONTAL
        graphViewport.backgroundColor = Color.argb(0, 255, 0, 0)
        serie.isDrawDataPoints = false
        serie.thickness = 3
        serie.color = Color.argb(80, 255, 255, 255)
    }

    private fun setupClocks(
        queryClock: String?,
        clock: Speedometer?,
        icon: TextView?,
        ray: RaySpeedometer?,
        max: Speedometer?
    ) {


        //todo: get all the min/max unit stuff for exlap items from schema.json
        var queryClock = queryClock
        val queryTrim: String
        val queryLong = queryClock
        var torqueUnit: String? = ""
        var torqueMin = 0
        var torqueMax = 100
        val typedArray2 =
            context!!.theme.obtainStyledAttributes(intArrayOf(R.attr.themedStopWatchBackground))
        val swBackgroundResource = typedArray2.getResourceId(0, 0)
        typedArray2.recycle()
        queryTrim = if (queryClock!!.contains("-")) {
            queryClock.substring(0, queryClock.indexOf("-")) // check the prefix
        } else {
            "other"
        }
        // get min/max values and unit from torque
        if (queryTrim == "torque") {
            queryClock = queryClock.substring(queryClock.lastIndexOf('_') + 1)
            queryClock = queryClock.substring(2)
            val queryPid = BigInteger(queryClock, 16).toLong()
            try {
                if (torqueService != null) {
                    torqueUnit = torqueService!!.getUnitForPid(queryPid)

                    //todo: use torque min and max values to determine min/max values for torque elements
                    torqueMin = Math.round(torqueService!!.getMinValueForPid(queryPid))
                    torqueMax = Math.round(torqueService!!.getMaxValueForPid(queryPid))
                    if (torqueMin == torqueMax) {
                        torqueMin =
                            torqueMax - 1 // prevent min and max are equal. Speedview cannot handle this.
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error: " + e.message)
            }
        } else {
            torqueMin = 0
            torqueMax = 100
        }
        Log.d(TAG, "minmax speed: $torqueMin $torqueMax")
        pressureUnit = "bar"
        pressureMax = 5
        pressureMin = -1
        when (queryLong) {
            "none" -> setupClock(icon, "ic_none", "", clock, false, "", 0, 100, "float", "float")
            "test" -> setupClock(
                icon,
                "ic_measurement",
                "",
                clock,
                false,
                getString(R.string.testing),
                0,
                360,
                "float",
                "integer"
            )

            "exlap-vehicleSpeed", "torque-speed_0x0d" -> setupClock(
                icon, "ic_none", "", clock, false, getString(
                    R.string.unit_kmh
                ), 0, 300, "integer", "integer"
            )

            "exlap-Nav_Altitude" -> setupClock(
                icon,
                "ic_altitude",
                "",
                clock,
                false,
                "m",
                -100,
                3000,
                "integer",
                "integer"
            )

            "exlap-Nav_Heading" -> {
                setupClock(icon, "ic_heading", "", clock, false, "", 0, 360, "integer", "integer")
                clock!!.markColor = Color.parseColor("#00FFFFFF")

                //set the degrees so it functions as a circle
                clock.setStartDegree(270)
                clock.setEndDegree(630)
                ray!!.setStartDegree(270)
                ray.setEndDegree(630)
                //min.setStartDegree(270);
                //min.setEndDegree(630);
                max!!.setStartDegree(270)
                max.setEndDegree(630)
                // set background resource to the same as stopwatch
                clock.setBackgroundResource(swBackgroundResource)
            }

            "exlap-engineSpeed", "torque-rpm_0x0c" -> {
                setupClock(
                    icon,
                    "ic_none",
                    getString(R.string.unit_rpm),
                    clock,
                    true,
                    getString(R.string.unit_rpm1000),
                    0,
                    9,
                    "float",
                    "integer"
                )
                clock!!.setTicks()
                clock.tickTextFormat = 0
            }

            "torque-voltage_0xff1238", "exlap-batteryVoltage", "torque-voltagemodule_0x42" -> setupClock(
                icon, "ic_battery", "", clock, false, getString(
                    R.string.unit_volt
                ), 0, 17, "float", "integer"
            )

            "exlap-oilTemperature", "torque-oiltemperature_0x5c" -> setupClock(
                icon,
                "ic_oil",
                "",
                clock,
                true,
                "",
                0,
                200,
                "float",
                "integer"
            )

            "exlap-coolantTemperature", "torque-enginecoolanttemp_0x05" -> setupClock(
                icon,
                "ic_water",
                "",
                clock,
                true,
                "",
                0,
                200,
                "float",
                "integer"
            )

            "exlap-outsideTemperature", "torque-ambientairtemp_0x46" -> setupClock(
                icon,
                "ic_outsidetemperature",
                "",
                clock,
                false,
                "",
                -25,
                50,
                "float",
                "integer"
            )

            "torque-transmissiontemp_0x0105", "torque-transmissiontemp_0xfe1805", "exlap-gearboxOilTemperature" -> setupClock(
                icon,
                "ic_gearbox",
                "",
                clock,
                false,
                "",
                0,
                200,
                "float",
                "integer"
            )

            "torque-turboboost_0xff1202" -> setupClock(
                icon,
                "ic_turbo",
                "",
                clock,
                true,
                torqueUnit,
                torqueMin,
                torqueMax,
                "float",
                "float"
            )

            "exlap-absChargingAirPressure", "exlap-relChargingAirPressure" -> setupClock(
                icon,
                "ic_turbo",
                "",
                clock,
                true,
                pressureUnit,
                pressureMin,
                pressureMax,
                "float",
                "integer"
            )

            "exlap-lateralAcceleration" -> setupClock(
                icon, "ic_lateral", "", clock, false, getString(
                    R.string.unit_g
                ), -3, 3, "float", "float"
            )

            "exlap-longitudinalAcceleration" -> setupClock(
                icon, "ic_longitudinal", "", clock, false, getString(
                    R.string.unit_g
                ), -3, 3, "float", "float"
            )

            "exlap-yawRate" -> setupClock(
                icon,
                "ic_yaw",
                "",
                clock,
                false,
                "/s",
                -1,
                1,
                "float",
                "integer"
            )

            "wheelAngle" -> setupClock(
                icon,
                "ic_wheelangle",
                "",
                clock,
                false,
                "",
                -45,
                45,
                "float",
                "integer"
            )

            "exlap-EcoHMI_Score.AvgShort", "exlap-EcoHMI_Score.AvgTrip" -> setupClock(
                icon,
                "ic_eco",
                "",
                clock,
                false,
                "",
                0,
                100,
                "integer",
                "integer"
            )

            "exlap-powermeter" -> setupClock(
                icon,
                "ic_powermeter",
                "",
                clock,
                false,
                "%",
                -1000,
                5000,
                "integer",
                "integer"
            )

            "exlap-acceleratorPosition" -> setupClock(
                icon,
                "ic_pedalposition",
                "",
                clock,
                false,
                "%",
                0,
                100,
                "integer",
                "integer"
            )

            "exlap-brakePressure" -> setupClock(
                icon,
                "ic_brakepedalposition",
                "",
                clock,
                false,
                "%",
                0,
                100,
                "integer",
                "integer"
            )

            "exlap-currentTorque" -> setupClock(
                icon,
                "ic_none",
                "",
                clock,
                false,
                getString(R.string.unit_nm),
                0,
                500,
                "integer",
                "integer"
            )

            "exlap-currentOutputPower" -> setupClock(
                icon,
                "ic_none",
                "",
                clock,
                false,
                getString(R.string.unit_kw),
                0,
                500,
                "integer",
                "integer"
            )

            "exlap-currentConsumptionPrimary", "exlap-cycleConsumptionPrimary" -> setupClock(
                icon,
                "ic_fuelprimary",
                "",
                clock,
                false,
                "l/100km",
                0,
                100,
                "float",
                "integer"
            )

            "exlap-currentConsumptionSecondary", "exlap-cycleConsumptionSecondary" -> setupClock(
                icon,
                "ic_fuelsecondary",
                "",
                clock,
                false,
                "l/100km",
                0,
                100,
                "float",
                "integer"
            )

            "exlap-tankLevelPrimary", "torque-fuellevel_0x2f" -> setupClock(
                icon,
                "ic_fuelprimary",
                "",
                clock,
                false,
                "l",
                0,
                100,
                "float",
                "integer"
            )

            "exlap-tankLevelSecondary" -> setupClock(
                icon,
                "ic_fuelsecondary",
                "",
                clock,
                false,
                "%",
                0,
                100,
                "float",
                "integer"
            )

            "torque-fuelpressure_0x0a" -> setupClock(
                icon,
                "ic_fuelpressure",
                getString(R.string.label_fuel),
                clock,
                false,
                torqueUnit,
                torqueMin,
                torqueMax,
                "float",
                "integer"
            )

            "torque-engineload_0x04", "torque-engineloadabsolute_0x43" -> setupClock(
                icon, "ic_none", getString(
                    R.string.label_load
                ), clock, false, torqueUnit, 0, 100, "float", "integer"
            )

            "torque-timing_advance_0x0e" -> setupClock(
                icon,
                "ic_timing",
                "",
                clock,
                false,
                torqueUnit,
                torqueMin,
                torqueMax,
                "float",
                "integer"
            )

            "torque-intake_air_temperature_0x0f" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_iat),
                clock,
                false,
                torqueUnit,
                0,
                100,
                "float",
                "integer"
            )

            "torque-mass_air_flow_0x10" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_maf),
                clock,
                false,
                torqueUnit,
                torqueMin,
                torqueMax,
                "float",
                "integer"
            )

            "torque-AFR_0xff1249" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_afr),
                clock,
                false,
                torqueUnit,
                0,
                35,
                "float",
                "integer"
            )

            "torque-AFRc_0xff124d" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_afrc),
                clock,
                false,
                torqueUnit,
                0,
                35,
                "float",
                "integer"
            )

            "torque-fueltrimshortterm1_0x06" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_ftst1),
                clock,
                false,
                torqueUnit,
                -20,
                20,
                "float",
                "integer"
            )

            "torque-fueltrimlongterm1_0x07" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_ftlt1),
                clock,
                false,
                torqueUnit,
                -20,
                20,
                "float",
                "integer"
            )

            "torque-fueltrimshortterm2_0x08" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_ftst2),
                clock,
                false,
                torqueUnit,
                -20,
                20,
                "float",
                "integer"
            )

            "torque-fueltrimlongterm2_0x09" -> setupClock(
                icon,
                "ic_none",
                getString(R.string.label_ftlt2),
                clock,
                false,
                torqueUnit,
                -20,
                20,
                "float",
                "integer"
            )

            "torque-accelerometer_total_0xff1223" -> setupClock(
                icon,
                "ic_none",
                "",
                clock,
                false,
                "G",
                -3,
                3,
                "float",
                "float"
            )

            "torque-phonebatterylevel_0xff129a" -> setupClock(
                icon,
                "ic_phone",
                "",
                clock,
                false,
                "%",
                0,
                100,
                "integer",
                "integer"
            )

            "torque-phonebarometer_0xff1270" -> setupClock(
                icon,
                "ic_barometer",
                "",
                clock,
                false,
                torqueUnit,
                torqueMin,
                torqueMax,
                "float",
                "integer"
            )

            "torque-obdadaptervoltage_0xff1238" -> setupClock(
                icon,
                "ic_obd2",
                "",
                clock,
                false,
                torqueUnit,
                0,
                17,
                "float",
                "integer"
            )

            "torque-hybridbattlevel_0x5b" -> setupClock(
                icon,
                "ic_battery",
                "",
                clock,
                false,
                "%",
                0,
                100,
                "float",
                "integer"
            )

            "torque-commandedequivalenceratiolambda_0x44" -> setupClock(
                icon,
                "ic_none",
                "lambda",
                clock,
                false,
                torqueUnit,
                0,
                3,
                "float",
                "float"
            )

            "torque-catalysttemperature_0x3c" -> setupClock(
                icon,
                "ic_catalyst",
                "",
                clock,
                false,
                torqueUnit,
                0,
                1000,
                "float",
                "integer"
            )

            "torque-relativethrottleposition_0x45", "torque-absolutethrottlepostion_0x47", "torque-throttle_position_0x11" -> setupClock(
                icon,
                "ic_throttle",
                "",
                clock,
                false,
                torqueUnit,
                0,
                100,
                "float",
                "integer"
            )

            "torque-intakemanifoldpressure_0x0b" -> setupClock(
                icon,
                "ic_manifold",
                "",
                clock,
                false,
                torqueUnit,
                0,
                200,
                "float",
                "integer"
            )

            "torque-chargeaircoolertemperature_0x77" -> setupClock(
                icon,
                "ic_cact",
                "",
                clock,
                false,
                torqueUnit,
                0,
                100,
                "float",
                "integer"
            )

            "torque-pressurecontrol_0x70" -> setupClock(
                icon,
                "ic_turbo",
                "",
                clock,
                false,
                pressureUnit,
                pressureMin * 30,
                pressureMax * 30,
                "float",
                "integer"
            )

            "torque-o2sensor1equivalenceratio_0x34" -> setupClock(
                icon,
                "ic_none",
                "O2 sensor",
                clock,
                false,
                torqueUnit,
                0,
                3,
                "float",
                "float"
            )

            "exlap-tyrePressures.pressureRearRight" -> setupClock(
                icon,
                "ic_tyre",
                getString(R.string.label_tyreRR),
                clock,
                false,
                pressureUnit,
                0,
                4,
                "float",
                "float"
            )

            "exlap-tyrePressures.pressureRearLeft" -> setupClock(
                icon,
                "ic_tyre",
                getString(R.string.label_tyreRL),
                clock,
                false,
                pressureUnit,
                0,
                4,
                "float",
                "float"
            )

            "exlap-tyrePressures.pressureFrontRight" -> setupClock(
                icon,
                "ic_tyre",
                getString(R.string.label_tyreFR),
                clock,
                false,
                pressureUnit,
                0,
                4,
                "float",
                "float"
            )

            "exlap-tyrePressures.pressureFrontLeft" -> setupClock(
                icon,
                "ic_tyre",
                getString(R.string.label_tyreFL),
                clock,
                false,
                pressureUnit,
                0,
                4,
                "float",
                "float"
            )

            "exlap-tyreTemperatures.temperatureRearRight" -> setupClock(
                icon,
                "ic_tyre",
                getString(R.string.label_tyreRR),
                clock,
                false,
                temperatureUnit,
                0,
                100,
                "float",
                "integer"
            )

            "exlap-tyreTemperatures.temperatureRearLeft" -> setupClock(
                icon,
                "ic_tyre",
                getString(R.string.label_tyreRL),
                clock,
                false,
                temperatureUnit,
                0,
                100,
                "float",
                "integer"
            )

            "exlap-tyreTemperatures.temperatureFrontRight" -> setupClock(
                icon, "ic_tyre", getString(
                    R.string.label_tyreFR
                ), clock, false, temperatureUnit, 0, 100, "float", "integer"
            )

            "exlap-tyreTemperatures.temperatureFrontLeft" -> setupClock(
                icon,
                "ic_tyre",
                getString(R.string.label_tyreFL),
                clock,
                false,
                temperatureUnit,
                0,
                100,
                "float",
                "integer"
            )

            "torque-exhaustgastempbank1sensor1_0x78" -> setupClock(
                icon,
                "ic_exhaust",
                "1",
                clock,
                false,
                torqueUnit,
                0,
                1000,
                "float",
                "integer"
            )

            "torque-exhaustgastempbank1sensor2_0xff1282" -> setupClock(
                icon,
                "ic_exhaust",
                "2",
                clock,
                false,
                torqueUnit,
                0,
                1000,
                "float",
                "integer"
            )

            "torque-exhaustgastempbank1sensor3_0xff1283" -> setupClock(
                icon,
                "ic_exhaust",
                "3",
                clock,
                false,
                torqueUnit,
                0,
                1000,
                "float",
                "integer"
            )

            "torque-exhaustgastempbank1sensor4_0xff1284" -> setupClock(
                icon,
                "ic_exhaust",
                "4",
                clock,
                false,
                torqueUnit,
                0,
                1000,
                "float",
                "integer"
            )

            "torque-fuelrailpressure_0x23" -> setupClock(
                icon,
                "ic_fuelpressure",
                "",
                clock,
                false,
                torqueUnit,
                0,
                100,
                "float",
                "integer"
            )
        }

        // make the icon appear in the color of unitTextColor
        val iconBackground = icon!!.background
        if (iconBackground != null) {
            val iconTint = clock!!.unitTextColor
            iconBackground.setColorFilter(iconTint, PorterDuff.Mode.SRC_ATOP)
            icon.background = iconBackground
            icon.setTextColor(iconTint)
        }

        // bring mins and max's in line with the clock
        val minimum = clock!!.getMinSpeed()
        val maximum = clock.getMaxSpeed()

        //min.setMinMaxSpeed(minimum, maximum);
        ray!!.setMinMaxSpeed(minimum, maximum)
        max!!.setMinMaxSpeed(minimum, maximum)
    }

    //update clock with data
    private fun updateClock(
        query: String?,
        clock: Speedometer?,
        visray: RaySpeedometer?,
        textmax: TextView?,
        clockmax: Speedometer?,
        graph: GraphView?,
        series: LineGraphSeries<DataPoint>?,
        graphLastXValue: Double,
        graphValue: TextView?,
        MaxSpeed: FloatArray?
    ) {
        var query = query
        if (query != null && stagingDone!!) {
            var speedFactor = 1f
            pressureFactor = 1f
            var clockValue = 0f
            val oldValue = clock!!.speed
            val queryLong: String = query
            var unitText = ""
            var temperatureUnitExlap =
                mLastMeasurements["unitTemperature.temperatureUnit"] as String?
            if (temperatureUnitExlap == null) {
                temperatureUnitExlap = ""
            }

            // Get the value that should be put on the clock, depending on the query
            // exlap queries use mLastMeasurements.get(query)
            // torque pid queries use torqueService.getValueForPid(queryPid), queryPid is trimmed from the query string
            val queryTrim =
                if (query.contains("-")) query.substring(0, query.indexOf("-")) else "other"
            when (queryTrim) {
                "torque" -> {
                    query = query.substring(query.lastIndexOf('_') + 1)
                    query = query.substring(2)
                    val queryPid = BigInteger(query, 16).toLong()
                    try {
                        if (torqueService != null) {
                            clockValue = torqueService!!.getValueForPid(queryPid, true)
                            unitText = torqueService!!.getUnitForPid(queryPid)
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error: " + e.message)
                    }
                }

                "exlap" -> {
                    query = query.substring(query.lastIndexOf('-') + 1)
                    clockValue = (mLastMeasurements[query] as Float?)!!
                }

                else -> clockValue = randFloat(0f, 360f)
            }
            if (clockValue != null) {
                when (queryLong) {
                    "test", "none" -> {}
                    "exlap-Nav_Heading", "exlap-batteryVoltage", "exlap-Nav_Altitude", "exlap-yawRate", "exlap-EcoHMI_Score.AvgShort", "exlap-EcoHMI_Score.AvgTrip", "exlap-brakePressure", "exlap-currentTorque", "exlap-lateralAcceleration" -> {}
                    "exlap-longitudinalAcceleration" -> clockValue = clockValue / 9.80665.toFloat()
                    "exlap-currentOutputPower" -> clockValue = clockValue * powerFactor
                    "exlap-engineSpeed", "torque-rpm_0x0c" -> clockValue = clockValue / 1000
                    "exlap-oilTemperature", "exlap-coolantTemperature", "exlap-outsideTemperature", "exlap-gearboxOilTemperature" -> clock.setUnit(
                        temperatureUnitExlap
                    )

                    "exlap-absChargingAirPressure", "exlap-relChargingAirPressure" -> clockValue =
                        clockValue * pressureFactor

                    "exlap-wheelAngle" -> clockValue =
                        clockValue * -1 // make it negative, otherwise right = left and vice versa
                    "exlap-powermeter" -> clockValue = clockValue - 1020
                    "exlap-acceleratorPosition", "exlap-tankLevelPrimary", "exlap-tankLevelSecondary" -> clockValue =
                        clockValue * fueltanksize

                    "exlap-currentConsumptionPrimary" -> {
                        val consumptionUnit =
                            mLastMeasurements["currentConsumptionPrimary.unit"] as String?
                        if (consumptionUnit != null) {
                            clock.setUnit(consumptionUnit)
                        }
                    }

                    "exlap-currentConsumptionSecondary" -> {
                        val consumption2Unit =
                            mLastMeasurements["currentConsumptionSecondary.unit"] as String?
                        if (consumption2Unit != null) {
                            clock.setUnit(consumption2Unit)
                        }
                    }

                    "exlap-cycleConsumptionPrimary" -> {
                        val cycconsumptionUnit =
                            mLastMeasurements["cycleConsumptionPrimary.unit"] as String?
                        if (cycconsumptionUnit != null) {
                            clock.setUnit(cycconsumptionUnit)
                        }
                    }

                    "exlap-cycleConsumptionSecondary" -> {
                        val cycconsumption2Unit =
                            mLastMeasurements["cycleConsumptionSecondary.unit"] as String?
                        if (cycconsumption2Unit != null) {
                            clock.setUnit(cycconsumption2Unit)
                        }
                    }

                    "exlap-vehicleSpeed" -> {
                        val speedUnit = mLastMeasurements["vehicleSpeed.unit"] as String?
                        if (speedUnit != null) {
                            when (speedUnit) {
                                "mph" -> {
                                    speedFactor = 1.60934f
                                    clock.setUnit("mph")
                                }

                                "kmh" -> {
                                    speedFactor = 1f
                                    clock.setUnit("kmh")
                                }
                            }
                            clockValue = clockValue * speedFactor
                        }
                    }

                    "exlap-tyrePressures.pressureRearRight", "exlap-tyrePressures.pressureRearLeft", "exlap-tyrePressures.pressureFrontRight", "exlap-tyrePressures.pressureFrontLeft" -> {
                        clock.setUnit(pressureUnit!!)
                        clockValue = clockValue / 10 * pressureFactor
                        clock.tickTextFormat = Gauge.FLOAT_FORMAT.toInt()
                    }

                    "exlap-tyreTemperatures.temperatureRearRight", "exlap-tyreTemperatures.temperatureRearLeft", "exlap-tyreTemperatures.temperatureFrontRight", "exlap-tyreTemperatures.temperatureFrontLeft" -> clock.setUnit(
                        temperatureUnitExlap
                    )

                    "torque-speed_0x0d", "torque-fuelpressure_0x0a", "torque-engineload_0x04", "torque-timing_advance_0x0e", "torque-mass_air_flow_0x10", "torque-throttle_position_0x11", "torque-AFR_0xff1249", "torque-AFRc_0xff124d", "torque-fueltrimshortterm1_0x06", "torque-fueltrimlongterm1_0x07", "torque-fueltrimshortterm2_0x08", "torque-fueltrimlongterm2_0x09", "torque-accelerometer_total_0xff1223", "torque-phonebatterylevel_0xff129a", "torque-phonebarometer_0xff1270", "torque-obdadaptervoltage_0xff1238", "torque-hybridbattlevel_0x5b", "torque-voltage_0xff1238", "torque-transmissiontemp2_0xfe1805", "torque-pressurecontrol_0x70", "torque-relativethrottleposition_0x45", "torque-absolutethrottlepostion_0x47", "torque-voltagemodule_0x42", "torque-ambientairtemp_0x46", "torque-intakemanifoldpressure_0x0b", "torque-commandedequivalenceratiolambda_0x44", "torque-o2sensor1equivalenceratio_0x34", "torque-engineloadabsolute_0x43", "torque-fuellevel_0x2f", "torque-fuelrailpressure_0x23" -> clock.setUnit(
                        unitText
                    ) // use the units Torque is providing
                    "torque-turboboost_0xff1202" -> {
                        if (unitText == "psi" && pressureUnit == "bar") {
                            clockValue = clockValue / 14.5037738f
                            unitText = "bar"
                        }
                        clock.setUnit(unitText)
                    }

                    "torque-intake_air_temperature_0x0f", "torque-transmissiontemp_0x0105", "torque-transmissiontemp_0xfe1805", "torque-oiltemperature_0x5c", "torque-catalysttemperature_0x3c", "torque-chargeaircoolertemperature_0x77", "torque-enginecoolanttemp_0x05", "torque-exhaustgastempbank1sensor1_0x78", "torque-exhaustgastempbank1sensor2_0xff1282", "torque-exhaustgastempbank1sensor3_0xff1283", "torque-exhaustgastempbank1sensor4_0xff1284" -> {
                        if (unitText == "C" && temperatureUnit == "C") {
                            unitText = "C"
                        } else {
                            unitText = "F"
                            clockValue = clockValue * 1.8f
                            clockValue = clockValue + 32
                        }
                        clock.setUnit(unitText)
                    }
                }

                // only shift x asis 0.5 positions when there's new data
                if (clock === mClockLeft) {
                    graphLeftLastXValue += 0.5
                } else if (clock === mClockCenter) {
                    graphCenterLastXValue += 0.5
                } else if (clock === mClockRight) {
                    graphRightLastXValue += 0.5
                }
                graph!!.viewport.setMaxY(clock.getMaxSpeed().toDouble())
                graph.viewport.setMinY(clock.getMinSpeed().toDouble())
            }

            // get the speed from the clock and have the high-visibility rays move to this speed as well
            val noNewData = clockValue == null
            if (noNewData) clockValue = oldValue


            //TODO: Updates with a non fixed period could lead to strange graphs
            series!!.appendData(DataPoint(graphLastXValue, clockValue.toDouble()), true, 2400)
            val tempString = String.format(Locale.US, FORMAT_DECIMALS, clockValue)
            graphValue!!.text = tempString


            // don't update when there's nothing to update
            // check if old value and new value (rounded to 1 decimal placed) are equal
            if (noNewData || Math.round(clockValue * 10) == Math.round(oldValue * 10)) {
                return
            }

            // update clock with latest clockValue
            clock.speedTo(clockValue)
            if (visray!!.isShown) {
                visray.speedTo(clockValue)
            }

            // update the max clocks and text
            val maxValue = clockmax!!.speed
            if (clockValue > maxValue) {
                if (clockmax.isShown) {
                    clockmax.setSpeedAt(clockValue)
                }
            }
            // Max Value update
            if (maxOn!! && clockValue > MaxSpeed!![dashboardNum]) {
                textmax!!.text = String.format(Locale.US, FORMAT_DECIMALS, clockValue)
                // Save max Value
                MaxSpeed[dashboardNum] = clockValue
            }
        }

        /*           // update the min clocks and text
                if (clockValueToGraph < minValue) {
                    clockmin.setSpeedAt(clockValueToGraph);
                    textmin.setText(String.format(Locale.US, getContext().getText(R.string.format_decimals).toString(), clockValueToGraph));
                }
      */
    }

    private val time: String
        private get() {
            var clockFormat = "hh:mm a"

            // If available, force car clock format
            val carClockFormat = mLastMeasurements["unitTimeFormat.clockFormat"] as String?
            if (carClockFormat != null) {
                when (carClockFormat) {
                    "format_24h" -> clockFormat = "HH:mm"
                    "format_12h" -> clockFormat = "hh:mm a"
                }
            } else { // if not, set time format based on phone settings
                clockFormat = androidClockFormat
            }
            return SimpleDateFormat(clockFormat, Locale.US).format(Date())
        }

    private fun checkTextNav(mText: String): Boolean {
        var mText = mText
        var mistWrong = false
        val str2 = " "
        val str3 = "  "
        mText = mText.trim { it <= ' ' }
        if (mText.contains(str2)) {
            mistWrong = true
        }
        if (mText.contains(str3)) {
            mistWrong = true
        }
        return mistWrong
    }

    private fun updateTitle() {
        val currentTitleValue = mTitleElement!!.text.toString()
        val currentRightTitleValue = mTitleElementRight!!.text.toString()
        val currentLeftTitleValue = mTitleElementLeft!!.text.toString()
        val currentNavDistanceTitleValue = mTitleElementNavDistance!!.text.toString()
        val currentNavTimeTitleValue = mTitleElementNavTime!!.text.toString()

        // Display location in center of title bar:
        val mProximity = mLastMeasurements["System_ProximityRecognition.InRange"] as Boolean?


        //mProximity = true;
        if (mProximity != null && mProximity && proximityOn!!) {
            val animation: ObjectAnimator
            animation = if (dashboardNum < 4) ObjectAnimator.ofFloat(
                mDashboard_gaudes,
                "y",
                90f
            ) else ObjectAnimator.ofFloat(mDashboard_consumption, "y", 90f)
            animation.duration = 200
            animation.start()
            mTitleClockLeft!!.text = mLabelClockL
            mTitleClockCenter!!.text = mLabelClockC
            mTitleClockRight!!.text = mLabelClockR
            mBtnNext!!.visibility = View.VISIBLE
            mBtnPrev!!.visibility = View.VISIBLE
            mtextTitleMain!!.visibility = View.VISIBLE
            // mtextTitleMain.setTextColor(Color.WHITE);
            mTitleConsumptionRight!!.visibility = View.VISIBLE
            mTitleConsumptionLeft!!.visibility = View.VISIBLE
            mTitleConsumptionCenter!!.visibility = View.VISIBLE
        } else if (!proximityOn!!) {
            val animation: ObjectAnimator
            animation = if (dashboardNum < 4) ObjectAnimator.ofFloat(
                mDashboard_gaudes,
                "y",
                90f
            ) else ObjectAnimator.ofFloat(mDashboard_consumption, "y", 90f)
            animation.duration = 200
            animation.start()
            mTitleClockLeft!!.text = ""
            mTitleClockCenter!!.text = ""
            mTitleClockRight!!.text = ""
            mBtnNext!!.visibility = View.VISIBLE
            mBtnPrev!!.visibility = View.VISIBLE
            mtextTitleMain!!.visibility = View.VISIBLE
            //mtextTitleMain.setTextColor(Color.WHITE);
            mTitleConsumptionRight!!.visibility = View.INVISIBLE
            mTitleConsumptionLeft!!.visibility = View.INVISIBLE
            mTitleConsumptionCenter!!.visibility = View.INVISIBLE
        } else {
            mTitleClockLeft!!.text = ""
            mTitleClockCenter!!.text = ""
            mTitleClockRight!!.text = ""
            mBtnNext!!.visibility = View.INVISIBLE
            mBtnPrev!!.visibility = View.INVISIBLE
            mtextTitleMain!!.visibility = View.INVISIBLE
            //mtextTitleMain.setTextColor(Color.DKGRAY);
            mTitleConsumptionRight!!.visibility = View.INVISIBLE
            mTitleConsumptionLeft!!.visibility = View.INVISIBLE
            mTitleConsumptionCenter!!.visibility = View.INVISIBLE
            val animation: ObjectAnimator
            animation = if (dashboardNum < 4) ObjectAnimator.ofFloat(
                mDashboard_gaudes,
                "y",
                45f
            ) else ObjectAnimator.ofFloat(mDashboard_consumption, "y", 45f)
            animation.duration = 200
            animation.start()
        }
        val currentTime = time
        if (currentTitleValue != currentTime) {
            mTitleElement!!.text = currentTime
        }

        // Display location in left side of Title bar
        if (showStreetName) {
            var leftTitle: String? = ""
            if (sourceLocation == "Geocoding") {
                leftTitle = googleGeocodeLocationStr
            } else {
                if (googleMapsLocationStr != null && !googleMapsLocationStr!!.isEmpty()) {
                    leftTitle = googleMapsLocationStr
                }
            }
            if (!forceGoogleGeocoding) {
                var location1 = mLastMeasurements["Nav_CurrentPosition.Street"] as String?
                var location2 = mLastMeasurements["Nav_CurrentPosition.City"] as String?
                if (location1 != null && checkTextNav(location1)) location1 = null
                if (location2 != null && checkTextNav(location2)) location2 = null
                if (location1 == null && location2 != null) leftTitle = location2
                if (location1 != null && location2 == null) leftTitle = location1
                if (location1 != null && location2 != null) leftTitle = "$location1, $location2"
            }
            if (currentLeftTitleValue != leftTitle) {
                mTitleElementLeft!!.text = leftTitle
            }
            if (leftTitle == "") {
                mTitleIcon2!!.visibility = View.INVISIBLE
            } else {
                mTitleIcon2!!.visibility = View.VISIBLE
            }
        }

        // Display temperature in right side of Title  bar
        var currentTemperature = mLastMeasurements["outsideTemperature"] as Float?
        if (currentTemperature != null) {
            if (!celsiusTempUnit) {
                currentTemperature = CarUtils.celsiusToFahrenheit(currentTemperature)
            }
            mTitleIcon1!!.visibility = View.VISIBLE
            val temperature = String.format(
                Locale.US,
                FORMAT_DECIMALS,
                currentTemperature
            ) + " " + temperatureUnit
            if (temperature != currentRightTitleValue) {
                mTitleElementRight!!.text = temperature
            }
        } else {
            mTitleIcon1!!.visibility = View.INVISIBLE
            mTitleElementRight!!.text = ""
        }

        // Display NAV Distance, only value <> 0
        var currentNavDistance = mLastMeasurements["Nav_GuidanceRemaining.DTD"] as Float?
        //     int testDistance = 35623;
        //    currentNavDistance = new Float(testDistance);
        if (currentNavDistance != null) {
            if (currentNavDistance != 0f) {
                currentNavDistance = currentNavDistance / 1000
                val NavDistance = String.format(Locale.US, "%.1f km", currentNavDistance)
                mTitleIcon3!!.visibility = View.VISIBLE
                mTitleElementNavDistance!!.visibility = View.VISIBLE
                if (NavDistance !== currentNavDistanceTitleValue) {
                    mTitleElementNavDistance!!.text = NavDistance
                }
            } else if (currentNavDistance == 0f) {
                mTitleIcon3!!.visibility = View.INVISIBLE
                mTitleElementNavDistance!!.visibility = View.INVISIBLE
                mTitleElementNavDistance!!.text = ""
            }
        } else if (currentNavDistance == null) {
            mTitleIcon3!!.visibility = View.INVISIBLE
            mTitleElementNavDistance!!.visibility = View.INVISIBLE
            mTitleElementNavDistance!!.text = ""
        }

        // Display NAV Time, only value <> 0
        val currentNavTime = mLastMeasurements["Nav_GuidanceRemaining.RTT"] as Float?


        //       int testValueTime = 2100;
        //       currentNavTime = new Float(testValueTime);
        val time = Date()
        val df = java.text.DateFormat.getTimeInstance(java.text.DateFormat.SHORT)
        if (currentNavTime != null) {
            if (currentNavTime != 0f) {
                //current time
                val NAVseconds = Math.round(currentNavTime)
                val gcal: Calendar = GregorianCalendar()
                gcal.time = time
                gcal.add(Calendar.SECOND, NAVseconds)
                val NAVTimeNew = gcal.time
                val NAVTime = df.format(NAVTimeNew)
                mTitleIcon4!!.visibility = View.VISIBLE
                mTitleElementNavTime!!.visibility = View.VISIBLE
                if (NAVTime !== currentNavTimeTitleValue) {
                    mTitleElementNavTime!!.text = NAVTime
                }
            } else if (currentNavTime == 0f) {
                mTitleIcon4!!.visibility = View.INVISIBLE
                mTitleElementNavTime!!.visibility = View.INVISIBLE
                mTitleElementNavTime!!.text = ""
            }
        } else if (currentNavTime == null) {
            mTitleIcon4!!.visibility = View.INVISIBLE
            mTitleElementNavTime!!.visibility = View.INVISIBLE
            mTitleElementNavTime!!.text = ""
        }
        val mNAVStreet = mLastMeasurements["Nav_GuidanceDestination.Street"] as String?
        val mNAVHousenumber = mLastMeasurements["Nav_GuidanceDestination.Housenumber"] as String?
        val mNAVCity = mLastMeasurements["Nav_GuidanceDestination.City"] as String?
        var mNAVadress = ""
        if (mNAVStreet != null && mNAVStreet != "") {
            mNAVadress = mNAVadress + mNAVStreet.trim { it <= ' ' } + " "
        }
        if (mNAVHousenumber != null && mNAVHousenumber != "") {
            mNAVadress = mNAVadress + mNAVHousenumber.trim { it <= ' ' }
        }
        if (mNAVCity != null && mNAVCity != "") {
            if (mNAVadress != "") mNAVadress = "$mNAVadress, "
            mNAVadress = mNAVadress + mNAVCity.trim { it <= ' ' }
        }
        mTitleNAVDestinationAddress!!.text = mNAVadress
        if (mProximity != null && mNAVadress != "" && mProximity) {
            mTitleNAVDestinationAddress!!.visibility = View.VISIBLE
            mTitleIcon4!!.visibility = View.INVISIBLE
            mTitleElementNavTime!!.visibility = View.INVISIBLE
            mTitleIcon3!!.visibility = View.INVISIBLE
            mTitleElementNavDistance!!.visibility = View.INVISIBLE
        } else {
            mTitleNAVDestinationAddress!!.visibility = View.INVISIBLE
        }
    }

    //update the elements
    private fun updateElement(queryElement: String?, value: TextView?, label: TextView?) {
        var queryElement = queryElement
        val queryPid: Long
        if (queryElement != null) {
            when (queryElement) {
                "none" -> value!!.text = ""
                "test" -> value!!.text =
                    String.format(Locale.US, FORMAT_DECIMALS, randFloat(0f, 100f))

                "torque-fuelpressure_0x0a",
                "torque-engineload_0x04",
                "torque-timing_advance_0x0e",
                "torque-intake_air_temperature_0x0f",
                "torque-mass_air_flow_0x10",
                "torque-throttle_position_0x11",
                "torque-voltage_0xff1238",
                "torque-AFR_0xff1249",
                "torque-AFRc_0xff124d",
                "torque-fueltrimshortterm1_0x06",
                "torque-fueltrimlongterm1_0x07",
                "torque-fueltrimshortterm2_0x08",
                "torque-fueltrimlongterm2_0x09",
                "torque-accelerometer_total_0xff1223",
                "torque-fuelrailpressure_0x23",
                "torque-exhaustgastempbank1sensor1_0x78",
                "torque-exhaustgastempbank1sensor2_0xff1282",
                "torque-exhaustgastempbank1sensor3_0xff1283",
                "torque-exhaustgastempbank1sensor4_0xff1284",
                "torque-absolutethrottlepostion_0x47",
                "torque-ambientairtemp_0x46",
                "torque-catalysttemperature_0x3c",
                "torque-chargeaircoolertemperature_0x77",
                "torque-commandedequivalenceratiolambda_0x44",
                "torque-enginecoolanttemp_0x05",
                "torque-engineloadabsolute_0x43",
                "torque-fuellevel_0x2f",
                "torque-intakemanifoldpressure_0x0b",
                "torque-o2sensor1equivalenceratio_0x34",
                "torque-obdadaptervoltage_0xff1238",
                "torque-oiltemperature_0x5c",
                "torque-phonebarometer_0xff1270",
                "torque-phonebatterylevel_0xff129a",
                "torque-pressurecontrol_0x70",
                "torque-relativethrottleposition_0x45",
                "torque-transmissiontemp_0x0105",
                "torque-transmissiontemp_0xfe1805",
                "torque-voltagemodule_0x42" -> {

// TODO: this seems useless, becuase we check the torqueQuery earlier than this
                    queryElement = queryElement.substring(queryElement.lastIndexOf('_') + 1)
                    queryElement = queryElement.substring(2)
                    queryPid = BigInteger(queryElement, 16).toLong()
                    val torqueData: Float
                    try {
                        if (torqueService != null) {
                            torqueData = torqueService!!.getValueForPid(queryPid, true)
                            val unitText = torqueService!!.getUnitForPid(queryPid)
                            value!!.text = String.format(
                                Locale.US,
                                FORMAT_DECIMALS_WITH_UNIT,
                                torqueData,
                                unitText
                            )
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error: " + e.message)
                    }
                }

                "torque-turboboost_0xff1202" -> {
                    queryElement = queryElement.substring(queryElement.lastIndexOf('_') + 1)
                    queryElement = queryElement.substring(2)
                    queryPid = BigInteger(queryElement, 16).toLong()
                    var torqueData3: Float
                    try {
                        if (torqueService != null) {
                            torqueData3 = torqueService!!.getValueForPid(queryPid, true)
                            var unitText = torqueService!!.getUnitForPid(queryPid)
                            // workaround for Torque displaying the unit for turbo pressure
                            if (unitText == "psi" && pressureUnit == "bar") {
                                torqueData3 = torqueData3 / 14.5037738f
                                unitText = "bar"
                            } else if (unitText == "bar" && pressureUnit == "psi") {
                                torqueData3 = torqueData3 * 14.5037738f
                                unitText = "psi"
                            }
                            value!!.text = String.format(
                                Locale.US,
                                FORMAT_DECIMALS_WITH_UNIT,
                                torqueData3,
                                unitText
                            )
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error: " + e.message)
                    }
                }

                "torque-rpm_0x0c",
                "torque-speed_0x0d" -> {
                    queryElement = queryElement.substring(queryElement.lastIndexOf('_') + 1)
                    queryElement = queryElement.substring(2)
                    queryPid = BigInteger(queryElement, 16).toLong()
                    try {
                        if (torqueService != null) {
                            val torqueData2 = torqueService!!.getValueForPid(queryPid, true)
                            val unitText = torqueService!!.getUnitForPid(queryPid)
                            value!!.text = String.format(Locale.US, FORMAT_NO_DECIMALS, torqueData2)
                            label!!.text = unitText
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error: " + e.message)
                    }
                }

                "batteryVoltage" -> {
                    val mBatteryVoltage = mLastMeasurements["batteryVoltage"] as Float?
                    if (mBatteryVoltage != null) {
                        value!!.text = String.format(Locale.US, FORMAT_VOLT, mBatteryVoltage)
                    }
                }

                "coolantTemperature",
                "oilTemperature",
                "gearboxOilTemperature" -> {
                    val mTemperature = mLastMeasurements[queryElement] as Float?
                    if (mTemperature != null && mTemperature > 0) {
                        value!!.text = String.format(Locale.US, FORMAT_DEGREES, mTemperature)
                        if (mTemperature < 70) {
                            value.setTextColor(Color.RED)
                        } else {
                            value.setTextColor(Color.WHITE)
                        }
                    }
                }

                "outsideTemperature" -> {
                    val mTemperatureOutside = mLastMeasurements[queryElement] as Float?
                    if (mTemperatureOutside != null) {
                        value!!.text = String.format(Locale.US, FORMAT_DEGREES, mTemperatureOutside)
                    }
                }

                "vehicleSpeed" -> {
                    val mVehicleSpeed = mLastMeasurements["vehicleSpeed"] as Float?
                    val speedUnit = mLastMeasurements["vehicleSpeed.unit"] as String?
                    if (mVehicleSpeed != null && speedUnit != null) {
                        value!!.text = String.format(Locale.US, FORMAT_DECIMALS, mVehicleSpeed)
                        label!!.text = speedUnit
                    }
                    val mNoDecimalValue = mLastMeasurements[queryElement] as Float?
                    if (mNoDecimalValue != null) {
                        value!!.text = String.format(Locale.US, FORMAT_NO_DECIMALS, mNoDecimalValue)
                    }
                }

                "engineSpeed",
                "Nav_Heading",
                "Nav_Altitude" -> {
                    val mNoDecimalValue = mLastMeasurements[queryElement] as Float?
                    if (mNoDecimalValue != null) {
                        value!!.text = String.format(Locale.US, FORMAT_NO_DECIMALS, mNoDecimalValue)
                    }
                }

                "currentOutputPower" -> {
                    val mCurrentPowerValue = mLastMeasurements[queryElement] as Float?
                    if (mCurrentPowerValue != null) {
                        // if (!powerUnits) {
                        //     // HP
                        //     mCurrentPowerValue *= powerFactor;
                        // }
                        value!!.text = String.format(Locale.US, FORMAT_DECIMALS, mCurrentPowerValue)
                        //label.setText(powerUnits?getString(R.string.unit_kw):getString(R.string.unit_hp));
                    }
                }

                "currentTorque" -> {
                    val mCurrentTorqueValue = mLastMeasurements[queryElement] as Float?
                    if (mCurrentTorqueValue != null) {
                        value!!.text =
                            String.format(Locale.US, FORMAT_DECIMALS, mCurrentTorqueValue)
                    }
                }

                "currentGear" -> {
                    val reverseGear = mLastMeasurements["reverseGear.engaged"] as Boolean?
                    val parkingBrake = mLastMeasurements["parkingBrake.engaged"] as Boolean?
                    val currentGear = mLastMeasurements["currentGear"] as String?
                    val recommendedGear = mLastMeasurements["recommendedGear"] as String?
                    var gearText = "-"
                    if (parkingBrake != null && parkingBrake) {
                        value!!.setTextColor(Color.WHITE)
                        gearText = "P"
                    } else if (reverseGear != null && reverseGear) {
                        value!!.setTextColor(Color.WHITE)
                        gearText = "R"
                    } else if (currentGear == null || currentGear == "0") {
                        value!!.setTextColor(Color.WHITE)
                        gearText = "-"
                    } else if (currentGear != null && recommendedGear != null) {
                        if (recommendedGear == currentGear || recommendedGear == "NoRecommendation") {
                            value!!.setTextColor(Color.WHITE)
                            gearText = convGear(currentGear)
                        } else if (recommendedGear != currentGear) {
                            value!!.setTextColor(Color.RED)
                            gearText = convGear(currentGear) + "" + convGear(recommendedGear)
                        }
                    }
                    value!!.text = gearText
                }

                "lateralAcceleration" -> {
                    val mAcceleration = mLastMeasurements[queryElement] as Float?
                    if (mAcceleration != null) {
                        value!!.text = String.format(Locale.US, FORMAT_GFORCE, mAcceleration)
                    }
                }

                "longitudinalAcceleration" -> {
                    var mAcceleration2 = mLastMeasurements[queryElement] as Float?
                    if (mAcceleration2 != null) {
                        mAcceleration2 =
                            mAcceleration2 / 9.80665.toFloat() //conversion from m/s to G force
                        value!!.text = String.format(Locale.US, FORMAT_GFORCE, mAcceleration2)
                    }
                }

                "yawRate" -> {
                    val mYawRate = mLastMeasurements[queryElement] as Float?
                    if (mYawRate != null) {
                        value!!.text = String.format(Locale.US, FORMAT_DEGREESPEC, mYawRate)
                    }
                }

                "Sound_Volume" -> {
                    val mSoundVol = mLastMeasurements[queryElement] as Float?
                    if (mSoundVol != null) {
                        value!!.text = String.format(Locale.US, FORMAT_NO_DECIMALS, mSoundVol)
                    }
                }

                "acceleratorPosition" -> {
                    val mAcceleratorPosition = mLastMeasurements["acceleratorPosition"] as Float?
                    if (mAcceleratorPosition != null) {
                        val mAccelPosPercent = mAcceleratorPosition * 100
                        value!!.text = String.format(Locale.US, FORMAT_DECIMALS, mAccelPosPercent)
                    }
                }

                "brakePressure" -> {
                    val mBrakePressure = mLastMeasurements["brakePressure"] as Float?
                    if (mBrakePressure != null) {
                        value!!.text = String.format(Locale.US, FORMAT_DECIMALS, mBrakePressure)
                    }
                }

                "wheelAngle" -> {
                    val mWheelAngle = mLastMeasurements[queryElement] as Float?
                    if (mWheelAngle != null) {
                        value!!.text = String.format(Locale.US, FORMAT_DEGREES, mWheelAngle)
                    }
                }

                "powermeter" -> {
                    val mPowermeter = mLastMeasurements[queryElement] as Float?
                    if (mPowermeter != null) {
                        value!!.text = String.format(Locale.US, FORMAT_NO_DECIMALS, mPowermeter)
                    }
                }

                "EcoHMI_Score.AvgShort",
                "EcoHMI_Score.AvgTrip" -> {
                    val mEcoScore = mLastMeasurements[queryElement] as Float?
                    if (mEcoScore != null) {
                        value!!.text = String.format(Locale.US, FORMAT_NO_DECIMALS, mEcoScore)
                    }
                }

                "shortTermConsumptionPrimary",
                "shortTermConsumptionSecondary" -> {
                    val mshortConsumption = mLastMeasurements[queryElement] as Float?
                    if (mshortConsumption != null) {
                        value!!.text = String.format(Locale.US, FORMAT_DECIMALS, mshortConsumption)
                    }
                }

                "Nav_CurrentPosition.Longitude",
                "Nav_CurrentPosition.Latitude",
                "Nav_CurrentPosition.City",
                "Nav_CurrentPosition.State",
                "Nav_CurrentPosition.Country",
                "Nav_CurrentPosition.Street",
                "Radio_Tuner.Name",
                "Radio_Text",
                "totalDistance.distanceValue",
                "vehicleIdenticationNumber.VIN" -> {
                    val elementValue = mLastMeasurements[queryElement] as String?
                    if (elementValue != null) value!!.text = elementValue
                }

                "blinkingState" -> {}
                "tyreStates.stateRearRight",
                "tyreStates.stateRearLeft",
                "tyreStates.stateFrontRight",
                "tyreStates.stateFrontLeft" -> {
                    val tyreState = mLastMeasurements[queryElement] as String?
                    if (tyreState != null) {
                        value!!.text = tyreState
                        //if (tyreState != "OK") value.setTextColor(Color.RED);
                    }
                }

                "tyrePressures.pressureRearRight",
                "tyrePressures.pressureRearLeft",
                "tyrePressures.pressureFrontRight",
                "tyrePressures.pressureFrontLeft" -> {
                    var tyrePressure = mLastMeasurements[queryElement] as Float?
                    if (tyrePressure != null) {
                        tyrePressure = tyrePressure / 10 // value in bar
                        tyrePressure = tyrePressure * pressureFactor // convert to psi if needed.
                        value!!.text = String.format(
                            Locale.US,
                            FORMAT_DECIMALS_WITH_UNIT,
                            tyrePressure,
                            pressureUnit
                        )
                    }
                }

                "tyreTemperatures.temperatureRearRight",
                "tyreTemperatures.temperatureRearLeft",
                "tyreTemperatures.temperatureFrontRight",
                "tyreTemperatures.temperatureFrontLeft" -> {
                    val tyreTemp = mLastMeasurements[queryElement] as Float?
                    if (tyreTemp != null) {
                        value!!.text = String.format(Locale.US, FORMAT_TEMPERATURE, tyreTemp)
                    }
                }

                "tankLevelPrimary",
                "tankLevelSecondary" -> {
                    val tankLevel = mLastMeasurements[queryElement] as Float?
                    if (tankLevel != null) {
                        value!!.text = String.format(Locale.US, FORMAT_PERCENT, tankLevel)
                    }
                }
            }
        }
    }

    // set clock label, units, etc.
    private fun setupClock(
        icon: TextView?,
        iconDrawableName: String,
        iconText: String,
        clock: Speedometer?,
        backgroundWithWarningArea: Boolean,
        unit: String?,
        minspeed: Int,
        maxspeed: Int,
        speedFormat: String,
        tickFormat: String
    ) {
        Log.d(TAG, "icon: $icon iconDrawableName: $iconDrawableName")
        val resId = resources.getIdentifier(iconDrawableName, "drawable", context!!.packageName)
        val iconDrawable = ContextCompat.getDrawable(context!!, resId)
        val resIdEmpty = resources.getIdentifier("ic_none", "drawable", context!!.packageName)
        val typedArray =
            context!!.theme.obtainStyledAttributes(intArrayOf(R.attr.themedEmptyDialBackground))
        val emptyBackgroundResource = typedArray.getResourceId(0, 0)
        typedArray.recycle()

        // set icon. Clocks that don't need an icon have ic_none as icon
        icon!!.background = iconDrawable
        icon.text = iconText
        clock!!.setUnit(unit!!)
        clock.setMinMaxSpeed(minspeed.toFloat(), maxspeed.toFloat())
        if (tickFormat === "float") {
            clock.tickTextFormat = Gauge.FLOAT_FORMAT.toInt()
        } else {
            clock.tickTextFormat = Gauge.INTEGER_FORMAT.toInt()
        }


        //dynamically scale the icon_space in case there's only an icon, and no text
        if (iconText != "" && resId == resIdEmpty) {
            val params = icon.layoutParams as ConstraintLayout.LayoutParams
            params.width = 40
            icon.layoutParams = params
        }


        // determine if an empty background, without red warning area is wanted
        if (!backgroundWithWarningArea) {
            clock.setBackgroundResource(emptyBackgroundResource)
        }

        //determine the clock format
        if (speedFormat == "float") {
            clock.speedTextFormat = Gauge.FLOAT_FORMAT.toInt()
        } else if (speedFormat == "integer") {
            clock.speedTextFormat = Gauge.INTEGER_FORMAT.toInt()
        }
    }

    private val torqueConnection: ServiceConnection = object : ServiceConnection {
        /**
         * What to do when we get connected to Torque.
         *
         * @param arg0
         * @param service
         */
        override fun onServiceConnected(arg0: ComponentName, service: IBinder) {
            torqueService = ITorqueService.Stub.asInterface(service)
        }

        /**
         * What to do when we get disconnected from Torque.
         *
         * @param name
         */
        override fun onServiceDisconnected(name: ComponentName) {
            torqueService = null
        }
    }

    // fade out 1 view, fade the other in during 500ms.
    private fun fadeOutfadeIn(oldView: View?, newView: View?) {
        oldView!!.animate()
            .alpha(0f)
            .setDuration(500)
            .setListener(object : AnimatorListenerAdapter() {
                override fun onAnimationEnd(animation: Animator) {
                    oldView.visibility = View.INVISIBLE
                    newView!!.visibility = View.VISIBLE
                    newView.alpha = 1f
                }
            })
        newView!!.alpha = 0f
        newView.visibility = View.VISIBLE
        newView.animate()
            .alpha(1f)
            .setDuration(500)
            .setListener(object : AnimatorListenerAdapter() {
                override fun onAnimationEnd(animation: Animator) {}
            })
    }

    // get min/max/units from exlap schema
    private fun getExlapDataElementDetails(query: String) {
        if (mSchema!!.containsKey(query)) {
            val field = mSchema[query]
            val minValue = field!!.min
            val maxValue = field.max
            val unit = field.unit
        }
    }

    companion object {
        // notation formats
        private const val FORMAT_DECIMALS = "%.1f"
        private const val FORMAT_DECIMALS_WITH_UNIT = "%.1f %s"
        private const val FORMAT_DEGREES = "%.1f"
        private const val FORMAT_GFORCE = "%.1fG"
        private const val FORMAT_KM = "%.1f km"
        private const val FORMAT_MILES = "%.1f miles"
        private const val FORMAT_NO_DECIMALS = "%.0f"
        private const val FORMAT_PERCENT = "%.1f"
        private const val FORMAT_DEGREESPEC = "%.1f/s"
        private const val FORMAT_TEMPERATURE = "%.1f"
        private const val FORMAT_VOLT = "%.1fV"

        // random, for use in Test value
        private fun randFloat(min: Float, max: Float): Float {
            val rand = Random()
            return rand.nextFloat() * (max - min) + min
        }

        fun convGear(gear: String?): String {
            var convertedGear = "0"
            when (gear) {
                "Gear1" -> convertedGear = "1"
                "Gear2" -> convertedGear = "2"
                "Gear3" -> convertedGear = "3"
                "Gear4" -> convertedGear = "4"
                "Gear5" -> convertedGear = "5"
                "Gear6" -> convertedGear = "6"
                "Gear7" -> convertedGear = "7"
                "Gear8" -> convertedGear = "8"
            }
            return convertedGear
        }

        private const val UPDATE_AFTER = 200 //ms
        private fun ConvertMinutesTime(minutesTime: Int): String {
            val timeZone = TimeZone.getTimeZone("UTC")
            val df = SimpleDateFormat("HH:mm")
            df.timeZone = timeZone
            return df.format(Date(minutesTime * 60 * 1000L))
        }
    }
}